<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Build a Simple Shape Drawing App</title>
</head>

<body>

<p>FlowSharpWeb - Build a Prototype Web-Based Diagramming App with SVG and Javascript<br>
Learning about to programmatically manipulate SVG in Javascript</p>
<p><img border="0" src="screenshot1.png" width="636" height="344"></p>
<p><a href="https://jsfiddle.net/cliftonm/o2ve65c9/">jsfiddle of this code</a></p>
<p><a href="https://github.com/cliftonm/FlowSharpWeb">On GitHub</a></p>
<h2>Contents</h2><ul>
<li><a href="#Introduction0">Introduction</a></li>
<ul>
<li><a href="#NoThirdPartyLibraries1">No Third Party Libraries</a></li>
<li><a href="#DescribingWhyandHow2">Describing Why and How</a></li>
<li><a href="#draw.io3">draw.io</a></li>
</ul>
<li><a href="#PrototypeBuild4">Prototype Build</a></li>
<li><a href="#CreatingaScrollableGrid5">Creating a Scrollable Grid</a></li>
<ul>
<li><a href="#SimulatingaVirtualSurface6">Simulating a Virtual Surface</a></li>
<li><a href="#ScrollingtheGrid-MouseEvents7">Scrolling the Grid - Mouse Events</a></li>
<ul>
<li><a href="#WiringuptheMouseEvents8">Wiring up the Mouse Events</a></li>
<li><a href="#BestPractice9">Best Practice</a></li>
<li><a href="#TheEventHandlers10">The Event Handlers</a></li>
<li><a href="#HandlingMovingtheMouseofftheGrid11">Handling Moving the Mouse off the Grid</a></li>
</ul>
</ul>
<li><a href="#ResizingtheGrid-OurFirstDynamicSVG12">Resizing the Grid - Our First Dynamic SVG</a></li>
<li><a href="#AddingSomeStaticShapes13">Adding Some Static Shapes</a></li>
<li><a href="#MovingShapesAround14">Moving Shapes Around</a></li>
<ul>
<li><a href="#TheMouseController15">The Mouse Controller</a></li>
<li><a href="#TheShapeObjectModel16">The Shape Object Model</a></li>
<ul>
<li><a href="#TheSvgObjectClass17">The SvgObject Class</a></li>
<li><a href="#TheSvgElementClass18">The SvgElement Class</a></li>
<li><a href="#TheCircleClass19">The Circle Class</a></li>
<li><a href="#TheSurfaceClass20">The Surface Class</a></li>
</ul>
<li><a href="#WrappingUpMovingShapes21">Wrapping Up Moving Shapes</a></li>
</ul>
<li><a href="#AToolboxandDynamicShapeCreation22">A Toolbox and Dynamic Shape Creation</a></li>
<ul>
<li><a href="#SupportingClasses23">Supporting Classes</a></li>
<li><a href="#Initialization24">Initialization</a></li>
<li><a href="#TheToolboxShapes25">The Toolbox Shapes</a></li>
<li><a href="#TheSvgToolboxElementClass26">The SvgToolboxElement Class</a></li>
<li><a href="#TheToolboxControllerClass27">The ToolboxController Class</a></li>
<ul>
<li><a href="#Constructor28">Constructor</a></li>
<li><a href="#ToolboxControlleronMouseDown29">Toolbox Controller onMouseDown</a></li>
<li><a href="#DeterminingaClickEvent30">Determining a Click Event</a></li>
<li><a href="#ToolboxControlleronMouseUp31">Toolbox Controller onMouseUp</a></li>
<li><a href="#ToolboxControlleronMouseMove32">Toolbox Controller onMouseMove</a></li>
<li><a href="#MouseControlleronMouseUp33">Mouse Controller onMouseUp</a></li>
</ul>
</ul>
<li><a href="#SavingandRestoringtheDiagramLocally34">Saving and Restoring the Diagram Locally</a></li>
<ul>
<li><a href="#SavingtheDiagram35">Saving the Diagram</a></li>
<li><a href="#LoadingtheDiagram36">Loading the Diagram</a></li>
</ul>
<li><a href="#LinesandAnchorPoints37">Lines and Anchor Points</a></li>
<ul>
<li><a href="#TheComplexitiesofSelectingALine38">The Complexities of Selecting A Line</a></li>
<li><a href="#PointClassandShapeRectangle39">Point Class and Shape Rectangle</a></li>
</ul>
<li><a href="#Anchors40">Anchors</a></li>
<ul>
<li><a href="#LineLengthandOrientation41">Line Length and Orientation</a></li>
</ul>
<li><a href="#AnchorDragOperationsforOtherShapes42">Anchor Drag Operations for Other Shapes</a></li>
<ul>
<li><a href="#Circles43">Circles</a></li>
<li><a href="#Diamonds44">Diamonds</a></li>
<li><a href="#Rectangles45">Rectangles</a></li>
</ul>
<li><a href="#Text46">Text</a></li>
<ul>
<li><a href="#ChangingText47">Changing Text</a></li>
</ul>
<li><a href="#RefactoringthePrototypetouseanMVCPattern48">Refactoring the Prototype to use an MVC Pattern</a></li>
<ul>
<li><a href="#Models,Views,andControllers49">Models, Views, and Controllers</a></li>
<li><a href="#TheTextModel50">The Text Model</a></li>
<li><a href="#TheTextController51">The Text Controller</a></li>
<li><a href="#TheTextView52">The Text View</a></li>
<li><a href="#TheBaseModel53">The Base Model</a></li>
<li><a href="#TheBaseView54">The Base View</a></li>
<li><a href="#CreatingaShapeProgrammatically55">Creating a Shape Programmatically</a></li>
<li><a href="#Serialization56">Serialization</a></li>
<li><a href="#Deserializing57">Deserializing</a></li>
</ul>
<li><a href="#ConnectingLines58">Connecting Lines</a></li>
<ul>
<li><a href="#ConnectionPoints59">Connection Points</a></li>
<li><a href="#DetectingShapesThatWe'reNear60">Detecting Shapes That We're Near</a></li>
<li><a href="#ShowingConnectionPoints61">Showing Connection Points</a></li>
<li><a href="#RemovingConnectionPoints62">Removing Connection Points</a></li>
<li><a href="#ConnectingtoaShape63">Connecting to a Shape</a></li>
<li><a href="#UpdatingConnectionswhentheShapeisMoved64">Updating Connections when the Shape is Moved</a></li>
<li><a href="#UpdatingConnectionswhentheShapeisResized65">Updating Connections when the Shape is Resized</a></li>
<li><a href="#DisconnectingConnections66">Disconnecting Connections</a></li>
</ul>
<li><a href="#RemovingAShape67">Removing A Shape</a></li>
<li><a href="#LineArrows">Line Arrows</a></li>
<li><a href="#Updates">Updates</a></li>
<li><a href="#Conclusion68">Conclusion</a></li>
</ul>

<h2><a name="Introduction0">Introduction</a></h2>
<p>I've been wanting to learn about SVG for a while now, and there are certainly 
any number of helpful websites on creating SVG drawings and animations.&nbsp; 
But I didn't want to learn how to create static (or even animated) SVG drawings, 
I wanted to learn how to use SVG dynamically:</p>
<ul>
	<li>Create, modify, and remove SVG elements dynamically.</li>
	<li>Hook events for moving elements around, changing their attributes, etc.</li>
	<li>Save and restore a drawing.</li>
	<li>Discover quirks and how to work around them.</li>
</ul>
<p>That's what this article is about -- it will only teach you SVG and 
Javascript in so far as to achieve the goals outlined above.&nbsp; However, what 
it will teach you is how to create dynamic SVG drawings, and what better way to 
do this than to actually create a simple drawing program.&nbsp; Then again, I 
learned a lot about both SVG and modern Javascript writing this article.</p>
<h3><a name="NoThirdPartyLibraries1">No Third Party Libraries</a></h3>
<p><u>No third party libraries are used in this code.</u>&nbsp; There were a few 
useful Javascript functions (in particular, the FileSaver) that I included in 
the source here that came from elsewhere (see the article for where), but there 
are no dependencies on any SVG manipulation frameworks.&nbsp; This code doesn't 
even use jQuery.&nbsp; In my opinion, this makes it a lot easier to learn SVG 
from the ground up -- you're <u>not</u> dealing with SVG + YAF (Yet Another 
Framework.)</p>
<h3><a name="DescribingWhyandHow2">Describing Why and How</a></h3>
<p>The point of this code and the code comments is to describe why I'm doing 
things in a certain way, and how I'm doing them.&nbsp; As this was a learning 
experience for myself, any time I had to reach out to the web to figure 
something out, I reference the source of the information -- this turns out to 
mostly be StackOverflow references!</p>
<h3><a name="draw.io3">draw.io</a></h3>
<p>One of the best online SVG drawing programs is <a href="https://www.draw.io/">
draw.io</a> and I'm not going to attempt to recreate it.&nbsp; However, like 
many things, it is often useful to &quot;roll your own&quot; to understand how the 
technologies is used.&nbsp; The online program draw.io is a nice front end for
<a href="http://jgraph.github.io/mxgraph/">mxgraph</a>, which has excellent 
documentation at <a href="https://jgraph.github.io/mxgraph/docs/manual.html">
https://jgraph.github.io/mxgraph/docs/manual.html</a>.&nbsp; Also see their API 
specifications which supports PHP, .NET, Java, and Javascript.&nbsp; If you're 
looking for a polished drawing program, similar to Visio, look at draw.io.&nbsp; 
If you want to<i> learn</i> about how 
this stuff is done, that's what this article is for.<i>&nbsp; </i></p>
<p>That said, let's begin!</p>
<h2><a name="PrototypeBuild4">Prototype Build</a></h2>
<p>The first two-thirds of this article is a prototype build.&nbsp; It vets the 
basic functionality and manipulation of the SVG DOM with UI interaction and 
diagram persistence.&nbsp; In particular, I implemented a very shallow 
view-controller architecture which gets completely replaced later on in the 
article.&nbsp; In the section that begins &quot;Refactoring the Prototype&quot; I move to 
a full model-view-controller, which cleans up a lot of the kludgy workarounds 
that you'll see here.&nbsp; Making the transition wasn't that painful -- 90% of 
the code was re-used in a proper MVC model, with the most significant changes 
occurring in the mouse controller and toolbox controller.&nbsp; And all cases of 
<code>instanceof</code> have been removed, something I considered quite a kludge in itself.</p>
<h2><a name="CreatingaScrollableGrid5">Creating a Scrollable Grid</a></h2>
<p><img border="0" src="grid1.png" width="276" height="200"></p>
<p>The first thing I wanted to learn how to do was create a grid that scrolls.&nbsp; 
It was easy enough to find an example on the Internet which I used as a starting 
point:</p>
<pre>&lt;svg id=&quot;svg&quot; width=&quot;801&quot; height=&quot;481&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
  &lt;defs&gt;
    &lt;pattern id=&quot;smallGrid&quot; width=&quot;8&quot; height=&quot;8&quot; patternUnits=&quot;userSpaceOnUse&quot;&gt;
      &lt;path d=&quot;M 8 0 H 0 V 8&quot; fill=&quot;none&quot; stroke=&quot;gray&quot; stroke-width=&quot;0.5&quot; /&gt;
    &lt;/pattern&gt;
    &lt;pattern id=&quot;grid&quot; width=&quot;80&quot; height=&quot;80&quot; patternUnits=&quot;userSpaceOnUse&quot;&gt;
      &lt;rect width=&quot;80&quot; height=&quot;80&quot; fill=&quot;url(#smallGrid)&quot; /&gt;
      &lt;!-- draw from upper right to upper left, then down to lower left --&gt;
      &lt;!-- This creates the appearance of an 80x80 grid when stacked --&gt;
      &lt;path d=&quot;M 80 0 H 0 V 80&quot; fill=&quot;none&quot; stroke=&quot;gray&quot; stroke-width=&quot;2&quot; /&gt;
    &lt;/pattern&gt;
  &lt;/defs&gt;

  &lt;!-- a trick from my old Commodore 64 days is to extend the scrolling region beyond the viewport 
  and use mod 80 to reset the position to simulate a virtual space. --&gt;
  &lt;rect transform=&quot;translate(0, 0)&quot; id=&quot;surface&quot; x=&quot;-80&quot; y=&quot;-80&quot; width=&quot;961&quot; height=&quot;641&quot; fill=&quot;url(#grid)&quot; /&gt;
&lt;/svg&gt;</pre>
<p>As I mentioned, I'm not going to go into the details of SVG but I will point 
out the core features:</p>
<ul>
	<li>There are two grids -- an outer grid every 80 pixels and an inner grid 
	every 8 pixels.</li>
	<li>The &quot;grid&quot; is actually created by drawing only two lines: the top line 
	(from right to left) and the left edge, from upper left to bottom left.&nbsp; 
	That's what the &quot;M 80 0 H 0 V 80&quot; does -- it creates a path starting at (80, 
	0), draws a horizontal line to (0, 0) and then a vertical line to (0, 80).</li>
	<li>The initial transform is a placeholder -- &quot;translate(0, 0)&quot; doesn't 
	actually do anything.</li>
</ul>
<h3><a name="SimulatingaVirtualSurface6">Simulating a Virtual Surface</a></h3>
<p><img border="0" src="bufferzone.png" width="217" height="163"></p>
<p>Notice that the rectangle is drawn with an off-screen buffer zone of (-80, 
-80) and (width + 80*2, height + 80*2).&nbsp; This is an old trick from which I 
used to program scrolling games on the Commodore 64 -- you would render the 
viewing area to include an off-screen buffer zone so that scrolling could be 
done simply by performing a translate (or on the C64, changing the screen memory 
pointer.)&nbsp; When scrolling a repeating pattern, one &quot;translates&quot; the 
viewable area +/- 80 mod 80 (the width and height of the grid) and it appears to 
the user as if there is an infinite virtual surface.</p>
<h3><a name="ScrollingtheGrid-MouseEvents7">Scrolling the Grid - Mouse Events</a></h3>
<p>The user scrolls the grid with a &quot;drag&quot; operation:</p>
<ul>
	<li>Mouse down to start.</li>
<li>Move mouse, which scrolls the grid.</li>
<li>Mouse up when done.</li>
</ul>
<p>We'll keep track of the following variables:</p>
<pre>var mouseDown = false;
var mouseDownX = 0;
var mouseDownY = 0;
var gridX = 0;
var gridY = 0;</pre>
<h4><a name="WiringuptheMouseEvents8">Wiring up the Mouse Events</a></h4>
<p>This is very simple (but we'll see later that it gets more complicated 
because for actual shapes that may be removed from the drawing, we will want to 
unhook the event handlers):</p>
<pre>function initializeSurface() {
  var svg = document.getElementById(&quot;svg&quot;);
  var surface = svg.getElementById(&quot;surface&quot;);
  surface.addEventListener(&quot;mousedown&quot;, onMouseDown, false);
  surface.addEventListener(&quot;mouseup&quot;, onMouseUp, false);
  surface.addEventListener(&quot;mousemove&quot;, onMouseMove, false);
  surface.addEventListener(&quot;mouseleave&quot;, onMouseLeave, false);
} 

initializeSurface();</pre>
<h4><a name="BestPractice9">Best Practice</a></h4>
<p>Technically, we could just get the surface element directly from the 
document:</p>
<pre>var svgSurface = document.getElementById(&quot;surface&quot;);</pre>
<p>but I suppose using the <code>svg</code> element helps to prevent the 
possibility that the HTML has an element of the same name, particularly since we 
don't know how the programmer might create additional HTML.</p>
<h4><a name="TheEventHandlers10">The Event Handlers</a></h4>
<p>Here we handle the <code>mousedown</code>, <code>mouseup</code>, and <code>mousemove</code> events:</p>
<pre>const LEFT_MOUSE_BUTTON = 0;

function onMouseDown(evt) {
  if (evt.button == LEFT_MOUSE_BUTTON) {
    evt.preventDefault();
    mouseDown = true;
    mouseDownX = evt.clientX;
    mouseDownY = evt.clientY;
  }
}

function onMouseUp(evt) {
  if (evt.button == LEFT_MOUSE_BUTTON) {
    evt.preventDefault();
    mouseDown = false;
  }
}

function onMouseMove(evt) {
  if (mouseDown) {
    evt.preventDefault();
    var mouseX = evt.clientX;
    var mouseY = evt.clientY;
    var mouseDX = mouseX - mouseDownX;
    var mouseDY = mouseY - mouseDownY;
    gridX += mouseDX;
    gridY += mouseDY;
    mouseDownX = mouseX;
    mouseDownY = mouseY;
    var svg = document.getElementById(&quot;svg&quot;);
    var surface = svg.getElementById(&quot;surface&quot;);
    var dx = gridX % 80;
    var dy = gridY % 80;
    surface.setAttribute(&quot;transform&quot;, &quot;translate(&quot; + dx + &quot;,&quot; + dy + &quot;)&quot;);
  }
}</pre>
<p>A few things to note:</p>
<ul>
	<li>Apparently, some browsers such as Firefox has default drag/drop handling 
	so we call <code>evt.preventDefault()</code> to, well, prevent the default handling of 
	the event.</li>
	<li>The variables <code>gridX</code> and <code>gridY</code> track the absolute offset grid.</li>
	<li>The grid is translated by this absolute offset modulus 80 so we don't 
	exceed the boundaries of the buffer zone.</li>
	<li>Apparently there used to be some confusing between the W3C standard 
	(left button == 0) and Microsoft's concept, (left button == 1) but that seems 
	to be very old information -- testing on Chrome and Edge, the left button 
	value (as well as right and middle values) are consistent across these two 
	browsers.</li>
</ul>
<h4><a name="HandlingMovingtheMouseofftheGrid11">Handling Moving the Mouse off the Grid</a></h4>
<p>There is no concept of &quot;mouse capture,&quot; so when the user drags the surface 
and the mouse moves outside of the SVG element, events, such as <code>mouseup</code>, are no 
longer received.&nbsp; If the user stops dragging <i>outside of the SVG element</i> 
by releasing the mouse button, the code is still in the dragging state because
the <code>mouseup</code> event didn't fire.&nbsp; So instead, when the mouse 
cursor leaves the element, we simulate a <code>mouseup</code> event by handling the <code>mouseleave</code> 
event.</p>
<pre>surface.addEventListener(&quot;mouseleave&quot;, onMouseLeave, false);

// If the mouse moves out of the surface area, the mouse up event will not trigger,
// so we clear the mouseDown flag so that scrolling does not resume &quot;by itself&quot; 
// when the user moves the mouse back onto the surface, which would otherwise 
// require the user to click to clear the mouseDown flag.
function onMouseLeave(evt) {
  evt.preventDefault();
  mouseDown = false;
}</pre>
<h2><a name="ResizingtheGrid-OurFirstDynamicSVG12">Resizing the Grid - Our First Dynamic SVG</a></h2>
<p><img border="0" src="grid2.png" width="363" height="248"></p>
<p>Of course, all the code above is hard-coded for a grid of dimensions 80x80 
with inner grid spacing of 8x8.&nbsp; We would like this to actually be user 
configurable.&nbsp; To do this, it's useful to rename some ID's and add 
additional ID's to the pattern 
definitions:</p>
<pre>&lt;defs&gt;
  &lt;pattern id=&quot;smallGrid&quot; width=&quot;8&quot; height=&quot;8&quot; patternUnits=&quot;userSpaceOnUse&quot;&gt;
    &lt;path id=&quot;smallGridPath&quot; d=&quot;M 8 0 H 0 V 8&quot; fill=&quot;none&quot; stroke=&quot;gray&quot; stroke-width=&quot;0.5&quot; /&gt;
  &lt;/pattern&gt;
  &lt;pattern id=&quot;largeGrid&quot; width=&quot;80&quot; height=&quot;80&quot; patternUnits=&quot;userSpaceOnUse&quot;&gt;
    &lt;rect id=&quot;largeGridRect&quot;width=&quot;80&quot; height=&quot;80&quot; fill=&quot;url(#smallGrid)&quot; /&gt;
    &lt;!-- draw from upper right to upper left, then down to lower left --&gt;
    &lt;!-- This creates the appearance of an 80x80 grid when stacked --&gt;
    &lt;path id=&quot;largeGridPath&quot; d=&quot;M 80 0 H 0 V 80&quot; fill=&quot;none&quot; stroke=&quot;gray&quot; stroke-width=&quot;2&quot; /&gt;
  &lt;/pattern&gt;
&lt;/defs&gt;</pre>
<p>For reasons that will become clear in the next section, I've also added a 
group around the rectangle that represents the grid:</p>
<pre>&lt;g id=&quot;surface&quot; transform=&quot;translate(0, 0)&quot; x=&quot;-80&quot; y=&quot;-80&quot; width=&quot;961&quot; height=&quot;641&quot; &gt;
  &lt;rect id=&quot;grid&quot; x=&quot;-80&quot; y=&quot;-80&quot; width=&quot;961&quot; height=&quot;641&quot; fill=&quot;url(#largeGrid)&quot; /&gt;
&lt;/g&gt; </pre>
<p>We need to track the width and height setting of the larger rectangles 
for modulus operator:</p>
<pre>// The default:
var gridCellW = 80;
var gridCellH = 80;</pre>
<p>and is used in the mousemove handler:</p>
<pre>var dx = gridX % gridCellW;
var dy = gridY % gridCellH;</pre>
<p>Given this function which changes the grid spacing to the screenshot at the 
start of this section, large grid is 100x100, small grid is 20x20:</p>
<pre>resizeGrid(100, 100, 20, 20);</pre>
<p>Here's the implementation:</p>
<pre> // Programmatically change the grid spacing for the larger grid cells and smaller grid cells.
function resizeGrid(lw, lh, sw, sh) {
  gridCellW = lw;
  gridCellH = lh;
  var elLargeGridRect = document.getElementById(&quot;largeGridRect&quot;);
  var elLargeGridPath = document.getElementById(&quot;largeGridPath&quot;);
  var elLargeGrid = document.getElementById(&quot;largeGrid&quot;);

  var elSmallGridPath = document.getElementById(&quot;smallGridPath&quot;);
  var elSmallGrid = document.getElementById(&quot;smallGrid&quot;);

  var elSvg = document.getElementById(&quot;svg&quot;);
  var elSurface = document.getElementById(&quot;surface&quot;);
  var elGrid = document.getElementById(&quot;grid&quot;);

  elLargeGridRect.setAttribute(&quot;width&quot;, lw);
  elLargeGridRect.setAttribute(&quot;height&quot;, lh);

  elLargeGridPath.setAttribute(&quot;d&quot;, &quot;M &quot; + lw + &quot; 0 H 0 V &quot; + lh);
  elLargeGrid.setAttribute(&quot;width&quot;, lw);
  elLargeGrid.setAttribute(&quot;height&quot;, lh);

  elSmallGridPath.setAttribute(&quot;d&quot;, &quot;M &quot; + sw + &quot; 0 H 0 V &quot; + sh);
  elSmallGrid.setAttribute(&quot;width&quot;, sw);
  elSmallGrid.setAttribute(&quot;height&quot;, sh);

  elGrid.setAttribute(&quot;x&quot;, -lw);
  elGrid.setAttribute(&quot;y&quot;, -lh);

  var svgW = +elSvg.getAttribute(&quot;width&quot;);
  var svgH = +elSvg.getAttribute(&quot;height&quot;);

  elSurface.setAttribute(&quot;width&quot;, svgW + lw * 2);
  elSurface.setAttribute(&quot;height&quot;, svgH + lh * 2);

  elSurface.setAttribute(&quot;x&quot;, -lw);
  elSurface.setAttribute(&quot;y&quot;, -lh);

  elSurface.setAttribute(&quot;width&quot;, svgW + lw * 2);
  elSurface.setAttribute(&quot;height&quot;, svgH + lh * 2);
}</pre>
<p>That's a lot of manipulation of the DOM elements.&nbsp; What we're doing is:</p>
<ul>
	<li>Resetting the width and height of the outer grid rectangle and the 
	pattern dimensions.</li>
	<li>Resetting the width and height of the inner grid pattern dimensions.</li>
	<li>Changing the path of the out and inner grids to reflect the new 
	dimensions.</li>
	<li>Resizing the buffer zone and surface dimensions.</li>
</ul>
<h2><a name="AddingSomeStaticShapes13">Adding Some Static Shapes</a></h2>
<p><img border="0" src="grid3.png" width="326" height="227"></p>
<p>Remember the group that I added around the grid rectangle?&nbsp; We'll now 
add another group that is used for shapes, and we'll put a couple static shapes 
in that group:</p>
<pre>&lt;g id=&quot;objects&quot; transform=&quot;translate(0, 0)&quot;&gt;
  &lt;circle cx=&quot;150&quot; cy=&quot;100&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;#FFC0C0&quot; /&gt;
  &lt;circle cx=&quot;175&quot; cy=&quot;125&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;#C0FFC0&quot; /&gt;
&lt;/g&gt;</pre>
<p>Now, with a simple addition to the <code>mousemove</code> event, we can translate all the 
elements in the &quot;objects&quot; group as well so that they move as the surface is 
scrolled:</p>
<pre>function onMouseMove(evt) {
  if (mouseDown) {
    evt.preventDefault();
    var mouseX = evt.clientX;
    var mouseY = evt.clientY;
    var mouseDX = mouseX - mouseDownX;
    var mouseDY = mouseY - mouseDownY;
    gridX += mouseDX;
    gridY += mouseDY;
    mouseDownX = mouseX;
    mouseDownY = mouseY;
    var surface = document.getElementById(&quot;surface&quot;);

    var dx = gridX % gridCellW;
    var dy = gridY % gridCellH;
    surface.setAttribute(&quot;transform&quot;, &quot;translate(&quot; + dx + &quot;,&quot; + dy + &quot;)&quot;);

    var objects = document.getElementById(&quot;objects&quot;);
    objects.setAttribute(&quot;transform&quot;, &quot;translate(&quot; + gridX + &quot;,&quot; + gridY + &quot;)&quot;);
  }
}</pre>
<p>The reason we use two separate groups is:</p>
<ul>
	<li>The surface is always translated modulus the large grid size</li>
<li>The objects <i>on the surface</i> must be translated by the absolute scroll 
offset.</li>
</ul>
<p>If we don't keep the two regions separate, we get the strange effect that the 
shapes return to their original positions as a result of the modulus operation.&nbsp; 
Obviously we don't want that.</p>
<h2><a name="MovingShapesAround14">Moving Shapes Around</a></h2>
<p>At this point, we have to start getting more sophisticated about how mouse 
events are captured -- each shape (including the surface) must handle its own 
mouse events.&nbsp; However, what the event does is not always the same -- for 
example, scrolling the surface grid is different than moving a shape in the 
&quot;objects&quot; group.&nbsp; Later on, even more complicated mouse move activities 
will require tracking the state of the operation -- are we moving the shape, 
resizing it, rotating it, etc.?</p>
<p>It's a big leap, but it really is of benefit to create an actual 
<code>MouseController</code> class and to create a shape controller class for the specialized behaviors of the 
different shapes.&nbsp; If we do this now, it becomes a lot easier to continue 
expanding the capabilities of what so far has just been a playground to test 
things out.</p>
<h3><a name="TheMouseController15">The Mouse Controller</a></h3>
<p>The <code>MouseController</code> class does a few things for us:</p>
<ul>
	<li>It tracks the shape being dragged.&nbsp; This is important because the 
	user can move the mouse in a larger increment than the size of the shape.&nbsp; 
	When this happens, the mouse &quot;escapes&quot; the shape and it no longer receives 
	<code>mousemove</code> events.&nbsp; So once a shape (including the surface 
	grid) is &quot;captured&quot; by <code>mousedown</code> event, the <code>mousemove</code> events are passed 
	along to the controller responsible for that shape.</li>
	<li>It maps shape ID's to shape controllers.&nbsp; This allows the mouse 
	controller to route mouse events to the controller associated with the 
	shape.</li>
	<li>It implements some basic behavioral features such as where the user 
	clicked and the basic logic of mouse down -&gt; drag -&gt; mouse up operations.&nbsp; 
	Later on additional states can be added besides dragging -- states such as 
	resizing.</li>
</ul>
<p>The implementation is rather basic right now, building on what we did before:</p>
<pre>const LEFT_MOUSE_BUTTON = 0;

class MouseController {
  constructor() {
    this.mouseDown = false;
    this.controllers = {};
    this.activeController = null;
  }

  // Create a map between then SVG element (by it's ID, so ID's must be unique) and its controller.
  attach(svgElement, controller) {
    var id = svgElement.getAttribute(&quot;id&quot;);
    this.controllers[id] = controller;
  }

  detach(svgElement) {
    var id = svgElement.getAttribute(&quot;id&quot;);
    delete this.controllers[id];
  }

  // Get the controller associated with the event and remember where the user clicked.
  onMouseDown(evt) {
    if (evt.button == LEFT_MOUSE_BUTTON) {
      evt.preventDefault();
      var id = evt.currentTarget.getAttribute(&quot;id&quot;);
      this.activeController = this.controllers[id];
      this.mouseDown = true;
      this.mouseDownX = evt.clientX;
      this.mouseDownY = evt.clientY;
    }
  }

  // If the user is dragging, call the controller's onDrag function.
  onMouseMove(evt) {
    evt.preventDefault();

    if (this.mouseDown &amp;&amp; this.activeController != null) {
      this.activeController.onDrag(evt);
    }
  }

  // Any dragging is now done.
  onMouseUp(evt) {
    if (evt.button == LEFT_MOUSE_BUTTON) {
      evt.preventDefault();
      this.clearSelectedObject();
    }
  }

  // Any dragging is now done.
  onMouseLeave(evt) {
    evt.preventDefault();
    if (this.mouseDown &amp;&amp; this.activeController != null) {
      this.activeController.onMouseLeave();
    }
  }

  clearSelectedObject() {
    this.mouseDown = false;
    this.activeController = null;
  }
}</pre>
<h3><a name="TheShapeObjectModel16">The Shape Object Model</a></h3>
<p><img border="0" src="svgmodel.png" width="539" height="226"></p>
<p>The diagram above illustrates the shape object model I've put together.</p>
<h4><a name="TheSvgObjectClass17">The SvgObject Class</a></h4>
<p>This is the root class which keeps track of:</p>
<ul>
	<li>The mouse controller (a shared object between all shapes).</li>
<li>The shape's translation (it's offset from origin).&nbsp; I've seen various 
techniques for this by using attributes directly in the elements tag rather than 
parsing the <code>transform=&quot;translate(x, y)&quot;</code> string in order to update the 
translation, but I'd rather keep this as variables in the shape's class 
instance.</li>
	<li>An event registration method so that when the shape is removed, all its 
	associated event handlers can be unhooked.</li>
	<li>Default implementations for the basic drag operation math and other 
	events.</li>
	<li>Binding the event handler to &quot;this&quot; as the default class instance or to 
	a specified class instance (usually the mouse controller.)</li>
</ul>
<pre>class SvgObject {
  constructor(mouseController, svgElement) {
    this.mouseController = mouseController;
    this.events = [];

    // These two parameters are actually the shape TRANSLATION, not the absolute coordinates!!!
    this.X = 0;
    this.Y = 0;

    // These two parameters are the relative change during the CURRENT translation.
    // These is reset to 0 at the beginning of each move.
    // We use these numbers for translating the anchors because anchors are always 
    // placed with an initial translation of (0, 0)
    this.dragX = 0;
    this.dragY = 0;

    this.mouseController.attach(svgElement, this);
  }

  // Register the event so that when we destroy the object, we can unwire the event listeners.
  registerEvent(element, eventName, callbackRef) {
    this.events.push({ element: element, eventName: eventName, callbackRef: callbackRef });
  }

  destroy() {
    this.unhookEvents();
  }

  registerEventListener(element, eventName, callback, self) {
    var ref;

    if (self == null) {
      self = this;
    }

    element.addEventListener(eventName, ref = callback.bind(self));
    this.registerEvent(element, eventName, ref);
  }

  unhookEvents() {
    for (var i = 0; i &lt; this.events.length; i++) {
      var event = this.events[i];
      event.element.removeEventListener(event.eventName, event.callbackRef);
    }

    this.events = [];
  }

  startMove() {
    this.dragX = 0;
    this.dragY = 0;
  }

  updatePosition(evt) {
    var mouseX = evt.clientX;
    var mouseY = evt.clientY;
    var mouseDX = mouseX - this.mouseController.mouseDownX;
    var mouseDY = mouseY - this.mouseController.mouseDownY;
    this.X += mouseDX;
    this.Y += mouseDY;
    this.mouseController.mouseDownX = mouseX;
    this.mouseController.mouseDownY = mouseY;
  }

  onMouseLeave(evt) { }
}</pre>
<h4><a name="TheSvgElementClass18">The SvgElement Class</a></h4>
<p>This class extends the <code>SvgObject</code> class, providing default mouse event 
registration and shape drag implementation:</p>
<pre>class SvgElement extends SvgObject {
  constructor(mouseController, svgElement) {
    super(mouseController, svgElement);
    this.element = svgElement;
    this.registerEventListener(this.element, &quot;mousedown&quot;, mouseController.onMouseDown, mouseController);
    this.registerEventListener(this.element, &quot;mouseup&quot;, mouseController.onMouseUp, mouseController);
    this.registerEventListener(this.element, &quot;mousemove&quot;, mouseController.onMouseMove, mouseController);
  }

  onDrag(evt) {
    this.updatePosition(evt);
    this.element.setAttribute(&quot;transform&quot;, &quot;translate(&quot; + this.X + &quot;,&quot; + this.Y + &quot;)&quot;);
  }
}</pre>
<p>Most of the time the &quot;this&quot; that is used to bind the event callback to the 
handling class instance will be the mouse controller, but the functionality has 
been provided to use the class instance registering the event (this is the 
default behavior) or some other class instance to which we want to bind the 
handler.</p>
<h4><a name="TheCircleClass19">The Circle Class</a></h4>
<p>The <code>Circle</code> class demonstrates the most basic of elements in which all the 
default behaviors can be utilized.&nbsp; It merely extends the <code>SvgElement</code> class.</p>
<pre>class Circle extends SvgElement {
  constructor(mouseController, svgElement) {
    super(mouseController, svgElement);
  }
}</pre>
<h4><a name="TheSurfaceClass20">The Surface Class</a></h4>
<p>This class is much more complicated as it has to handle all the things we 
talked about before regarding scrolling the grid and objects on the grid.&nbsp; 
Note how it extends the <code>mouseleave</code> event.&nbsp; We want this to 
pass through the mouse controller's test to ensure that a drag operation is 
occurring when the mouse &quot;leaves&quot; the shape.&nbsp; Depending on the selected 
shape (the active controller) the behavior is different:</p>
<ul>
	<li>in case of leaving the surface, the surface class is implemented such 
	that the drag operation is cleared.</li>
<li>In the case of leaving a shape, nothing happens as we want the shape to 
catch up to mouse position.</li>
</ul>
<pre>class Surface extends SvgElement {
  constructor(mouseController, svgSurface, svgObjects) {
    super(mouseController, svgSurface);
    this.svgObjects = svgObjects;
    this.gridCellW = 80;
    this.gridCellH = 80;

    this.registerEventListener(this.svgSurface, &quot;mouseleave&quot;, mouseController.onMouseLeave, mouseController);
  }

  onDrag(evt) {
    this.updatePosition();
    var dx = this.X % this.gridCellW;
    var dy = this.Y % this.gridCellH;
    this.scrollSurface(dx, dy, this.X, this.Y);
  }

  onMouseLeave() {
    this.mouseController.clearSelectedObject();
  }

  scrollSurface(dx, dy, x, y) {
    // svgElement is the surface.
    this.svgElement.setAttribute(&quot;transform&quot;, &quot;translate(&quot; + dx + &quot;,&quot; + dy + &quot;)&quot;);
    this.svgObjects.setAttribute(&quot;transform&quot;, &quot;translate(&quot; + x + &quot;,&quot; + y + &quot;)&quot;);
  }

 function resizeGrid(lw, lh, sw, sh) {
    this.gridCellW = lw;
    this.gridCellH = lh;
    var elLargeGridRect = document.getElementById(&quot;largeGridRect&quot;);
    var elLargeGridPath = document.getElementById(&quot;largeGridPath&quot;);
    var elLargeGrid = document.getElementById(&quot;largeGrid&quot;);

    var elSmallGridPath = document.getElementById(&quot;smallGridPath&quot;);
    var elSmallGrid = document.getElementById(&quot;smallGrid&quot;);

    var elSvg = document.getElementById(&quot;svg&quot;);
    var elSurface = document.getElementById(&quot;surface&quot;);
    var elGrid = document.getElementById(&quot;grid&quot;);

    elLargeGridRect.setAttribute(&quot;width&quot;, lw);
    elLargeGridRect.setAttribute(&quot;height&quot;, lh);

    elLargeGridPath.setAttribute(&quot;d&quot;, &quot;M &quot; + lw + &quot; 0 H 0 V &quot; + lh);
    elLargeGrid.setAttribute(&quot;width&quot;, lw);
    elLargeGrid.setAttribute(&quot;height&quot;, lh);

    elSmallGridPath.setAttribute(&quot;d&quot;, &quot;M &quot; + sw + &quot; 0 H 0 V &quot; + sh);
    elSmallGrid.setAttribute(&quot;width&quot;, sw);
    elSmallGrid.setAttribute(&quot;height&quot;, sh);

    elGrid.setAttribute(&quot;x&quot;, -lw);
    elGrid.setAttribute(&quot;y&quot;, -lh);

    var svgW = elSvg.getAttribute(&quot;width&quot;);
    var svgH = elSvg.getAttribute(&quot;height&quot;);

    elSurface.setAttribute(&quot;width&quot;, svgW + lw * 2);
    elSurface.setAttribute(&quot;height&quot;, svgH + lh * 2);
    
    elSurface.setAttribute(&quot;x&quot;, -lw);
    elSurface.setAttribute(&quot;y&quot;, -lh);

    elSurface.setAttribute(&quot;width&quot;, svgW + lw * 2);
    elSurface.setAttribute(&quot;height&quot;, svgH + lh * 2);
  }
}</pre>
<h3><a name="WrappingUpMovingShapes21">Wrapping Up Moving Shapes</a></h3>
<p><img border="0" src="grid4.png" width="263" height="195"></p>
<p>To get this all to work, we need to add ID's to the two static circles in the 
&quot;objects&quot; group:</p>
<pre>&lt;g id=&quot;objects&quot; transform=&quot;translate(0, 0)&quot;&gt;
  &lt;circle id=&quot;circle1&quot; cx=&quot;150&quot; cy=&quot;100&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;#FFC0C0&quot; /&gt;
  &lt;circle id=&quot;circle2&quot; cx=&quot;175&quot; cy=&quot;125&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;#C0FFC0&quot; /&gt;
&lt;/g&gt;</pre>
<p>We then create the class instances and in the constructor pass in the mouse 
controller instance and shape element:</p>
<pre>(function initialize() {
  var mouseController = new MouseController();
  var svgSurface = document.getElementById(&quot;surface&quot;);
  var svgObjects = document.getElementById(&quot;objects&quot;);
  var svgCircle1 = document.getElementById(&quot;circle1&quot;);
  var svgCircle2 = document.getElementById(&quot;circle2&quot;);
  var surface = new Surface(mouseController, svgSurface, svgObjects);
  surface.resizeGrid(100, 100, 20, 20);
  new Circle(mouseController, svgCircle1);
  new Circle(mouseController, svgCircle2);
})();</pre>
<p>That's it!&nbsp; But where are we actually dragging the shapes?&nbsp; This 
may have escaped the casual reader--it is happening in the SvgElement class!</p>
<pre>onDrag(evt) {
  this.updatePosition(evt);
  this.element.setAttribute(&quot;transform&quot;, &quot;translate(&quot; + this.X + &quot;,&quot; + this.Y + &quot;)&quot;);
}</pre>
<p>Any shape that derives from <code>SvgElement</code> inherits the ability to be dragged 
around the surface.&nbsp; For example, we'll add a rectangle:</p>
<pre>&lt;rect id=&quot;nose&quot; x=&quot;200&quot; y=&quot;150&quot; width=&quot;40&quot; height=&quot;60&quot; stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;#C0C0FF&quot; /&gt;</pre>
<p>Define the class <code>Rectangle</code>, which doesn't override anything yet, just like <code>Circle</code>:</p>
<pre>class Rectangle extends SvgElement {
  constructor(mouseController, svgElement) {
    super(mouseController, svgElement);
  }
}</pre>
<p>and instantiate the shape with the associated SVG element:</p>
<pre>new Rectangle(mouseController, document.getElementById(&quot;nose&quot;));</pre>
<p>and we get (after moving the shapes around):</p>
<p><img border="0" src="grid5.png" width="256" height="209"></p>
<h2><a name="AToolboxandDynamicShapeCreation22">A Toolbox and Dynamic Shape Creation</a></h2>
<p>Let's make what we're doing more useful by adding a toolbox so we can drag 
and drop new shapes on the surface.&nbsp; The toolbox will be the third group, 
making it the topmost group so that everything else (grid and objects) are 
always rendered <i>behind</i> the toolbox:</p>
<pre>&lt;g id=&quot;toolboxGroup&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;200&quot; height=&quot;480&quot;&gt;
  &lt;rect id=&quot;toolbox&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;200&quot; height=&quot;480&quot; fill=&quot;#FFFFFF&quot; stroke=&quot;black&quot; stroke-width=&quot;0.5&quot; /&gt;
  &lt;rect id=&quot;toolboxRectangle&quot; x=&quot;10&quot; y=&quot;10&quot; width=&quot;40&quot; height=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;#FFFFFF&quot; /&gt;
  &lt;circle id=&quot;toolboxCircle&quot; cx=&quot;85&quot; cy=&quot;29&quot; r=&quot;21&quot; stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;#FFFFFF&quot; /&gt;
  &lt;path id=&quot;toolboxDiamond&quot; d=&quot;M 140 10 L 115 30 L 140 50 L 165 30 Z&quot; stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;#FFFFFF&quot; /&gt;
&lt;/g&gt;</pre>
<p><img border="0" src="toolbox1.png" width="446" height="217"></p>
<h3><a name="SupportingClasses23">Supporting Classes</a></h3>
<p>We're going to need a some additional classes (indicated with the red text):</p>
<p><img border="0" src="toolbox2.png" width="709" height="331"></p>
<h3><a name="Initialization24">Initialization</a></h3>
<p>Here's the entire initialization code (I've removed the static shapes we had 
previously):</p>
<pre>const SVG_ELEMENT_ID = &quot;svg&quot;;
const SVG_SURFACE_ID = &quot;surface&quot;;
const SVG_TOOLBOX_SURFACE_ID = &quot;toolboxSurface&quot;;
const SVG_OBJECTS_ID = &quot;objects&quot;;

(function initialize() {
  var mouseController = new MouseController();
  var svgSurface = getElement(SVG_SURFACE_ID);
  var svgToolboxSurface = getElementBy(SVG_TOOLBOX_SURFACE_ID);
  var svgObjects = getElement(SVG_OBJECTS_ID);

  var surface = new Surface(mouseController, svgSurface, svgObjects);
  surface.resizeGrid(100, 100, 20, 20);

  var toolboxController = new ToolboxController(mouseController);

  // So we can handle mouse drag operations when the mouse moves onto the toolbox surface...
  var toolboxSurface = new ToolboxSurface(toolboxController, svgToolboxSurface);

  // The surface mouse controller needs to know the toolbox controller to finish
  // a toolbox drag &amp; drop operation.
  mouseController.setToolboxController(toolboxController);
  // To compensate for translations when doing a toolbox drag&amp;drop
  mouseController.setSurfaceShape(surface);
  toolboxController.setSurfaceShape(surface);

  new ToolboxRectangle(toolboxController, getElement(&quot;toolboxRectangle&quot;));
  new ToolboxCircle(toolboxController, getElement(&quot;toolboxCircle&quot;));
  new ToolboxDiamond(toolboxController, getElement(&quot;toolboxDiamond&quot;));
})();</pre>
<p>Notice some changes (will be explained next):</p>
<ul>
	<li>There are setter methods to tell the mouse controller (which handles the 
	surface) about the toolbox controller and surface &quot;shape.&quot;&nbsp; This will 
	be explained shortly.</li>
	<li>The toolbox controller is derived from the mouse controller, as it is a 
	specialized mouse controller for handling drag &amp; drop as well as &quot;click and 
	drop&quot; operations.</li>
	<li>The toolbox controller needs to know about the surface &quot;shape.&quot;</li>
	<li>Lastly, we initialize the objects backing the toolbox shapes.</li>
</ul>
<p>I also added a simple helper method that, granted, I'm not using everywhere, 
but is less typing:</p>
<pre>function getElement(id) {
  var svg = document.getElementById(SVG_ELEMENT_ID);
  var el = svg.getElementById(id);

  return el;
}</pre>
<p>Also, the better practice here is that the we're looking for element ID's in 
the &quot;svg&quot; element, not the document.</p>
<h3><a name="TheToolboxShapes25">The Toolbox Shapes</a></h3>
<p>The toolbox shapes all implement the following functions:</p>
<ul>
	<li>createElement - this creates an element with a starting location to 
	place it on the surface next to the toolbox.&nbsp; This is used for &quot;click 
	and drop&quot; operations.</li>
	<li>createElementAt - this creates an element at the specified location.&nbsp; 
	This is used for &quot;drag and drop&quot; operations.</li>
	<li>createShape - instantiates the associated non-toolbox shape.</li>
</ul>
<p>So, for example (choosing the diamond because it's a bit more complex):</p>
<pre>class ToolboxDiamond extends SvgToolboxElement {
  constructor(toolboxController, svgElement) {
    super(toolboxController, svgElement);
  }

  // For click and drop
  createElement() {
    var el = super.createElement('path', 
      { d: &quot;M 240 100 L 210 130 L 240 160 L 270 130 Z&quot;, stroke: &quot;black&quot;, &quot;stroke-width&quot;: 1, fill: &quot;#FFFFFF&quot; });

    return el;
  }

  // For drag and drop
  createElementAt(x, y) {
    var points = [
      { cmd: &quot;M&quot;, x: x-15, y: y-30 }, 
      { cmd: &quot;L&quot;, x: x - 45, y: y }, 
      { cmd: &quot;L&quot;, x: x-15, y: y + 30 }, 
      { cmd: &quot;L&quot;, x: x + 15, y: y }];

    var path = points.reduce((acc, val) =&gt; acc = acc + val.cmd + &quot; &quot; + val.x + &quot; &quot; + val.y, &quot;&quot;);
    path = path + &quot; Z&quot;;
    var el = super.createElement('path', { d: path, stroke: &quot;black&quot;, &quot;stroke-width&quot;: 1, fill: &quot;#FFFFFF&quot; });

    return el;
  }

  createShape(mouseController, el) {
    var shape = new Diamond(mouseController, el);

    return shape;
  }
}</pre>
<p>All the toolbox shapes follow the above template.</p>
<h3><a name="TheSvgToolboxElementClass26">The SvgToolboxElement Class</a></h3>
<p>The base class for all toolbox elements wires up the mouse events for toolbox 
shape elements to the <i>toolboxController</i>.&nbsp; It also provides a common 
method for creating an element and setting its attributes, including creating a 
unique ID for the element:</p>
<pre>class SvgToolboxElement extends SvgObject {
  constructor(toolboxController, svgElement) {
    super(toolboxController, svgElement);
    this.toolboxController = toolboxController;
    this.registerEventListener(svgElement, &quot;mousedown&quot;, toolboxController.onMouseDown, toolboxController);
    this.registerEventListener(svgElement, &quot;mouseup&quot;, toolboxController.onMouseUp, toolboxController);
    this.registerEventListener(svgElement, &quot;mousemove&quot;, toolboxController.onMouseMove, toolboxController);
    this.svgns = &quot;<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>&quot;;
  }

  // Create the specified element with the attributes provided in a key-value dictionary.
  createElement(elementName, attributes) {
    var el = document.createElementNS(this.svgns, elementName);

    // Create a unique ID for the element so we can acquire the correct shape controller
    // when the user drags the shape.
    el.setAttributeNS(null, &quot;id&quot;, this.uuidv4());

    // Create a class common to all shapes so that, on file load, we can get them all and re-attach them
    // to the mouse controller.
    el.setAttributeNS(null, &quot;class&quot;, SHAPE_CLASS_NAME);

    // Add the attributes to the element.
    Object.entries(attributes).map(([key, val]) =&gt; el.setAttributeNS(null, key, val));

    return el;
  }

  // From SO: <a href="https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript">https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript</a>
  uuidv4() {
    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =&gt; 
      (c ^ crypto.getRandomValues(new Uint8Array(1))[0] &amp; 15 &gt;&gt; c / 4).toString(16))
  }
}</pre>
<h3><a name="TheToolboxControllerClass27">The ToolboxController Class</a></h3>
<p>Most of how the &quot;click and drop&quot; and &quot;drag and drop&quot; behavior is handled 
here.&nbsp; Remember that this class derives from MouseController, however it 
also needs to be initialized with the <i>surface</i> mouse controller -- it gets 
interesting (or perhaps confusing) to have two mouse controllers in this class!</p>
<h4><a name="Constructor28">Constructor</a></h4>
<pre>class ToolboxController extends MouseController {
  // We pass in the mouse controller that the surface is using so we can 
  // pass control over to the surface mouse controller when dragging a shape.
  constructor(mouseController) {
    super();
    this.mouseController = mouseController;
    this.draggingShape = false;
  }</pre>
<p>As the comments state, we need the <i>surface</i> mouse controller so that 
for drag &amp; drop operations, we can pass off the shape dragging to the <i>surface</i> 
mouse controller.&nbsp; When dragging, a non-toolbox shape is created.&nbsp; 
This shape wires up the mouse events using the <i>surface</i> mouse controller, 
which is why we need to pass control over to that controller.&nbsp; The 
alternative would be to tell the shape how to route the mouse events, and once 
the shape is dropped onto the surface, the events would have to be detached from 
the toolbox controller and attached to the surface mouse controller.&nbsp; So it 
merely shoves the problem around.&nbsp; Still, there might be a better way to do 
this.</p>
<h4><a name="ToolboxControlleronMouseDown29">Toolbox Controller onMouseDown</a></h4>
<pre>onMouseDown(evt) {
  super.onMouseDown(evt);
}</pre>
<p>We let the base class handle this behavior.&nbsp; The event is wired up to 
the toolbox controller.</p>
<h4><a name="DeterminingaClickEvent30">Determining a Click Event</a></h4>
<pre>isClick(evt) {
  var endDownX = evt.clientX;
  var endDownY = evt.clientY;

  var isClick = Math.abs(this.startDownX - endDownX) &lt; TOOLBOX_DRAG_MIN_MOVE &amp;&amp;
                Math.abs(this.startDownY - endDownY) &lt; TOOLBOX_DRAG_MIN_MOVE;

  return isClick;
}</pre>
<p>While we could use the &quot;onclick&quot; event, I want finer grained control and I 
don't want to deal with whether the click event fires after a mouse up &quot;click 
and drag&quot; vs. a mouse up &quot;drag and drop.&quot;&nbsp; OK, I still have to worry about 
that, but it makes more sense (to me at least) to just handle this in the mouse 
up event.</p>
<h4><a name="ToolboxControlleronMouseUp31">Toolbox Controller onMouseUp</a></h4>
<pre>// If this is a &quot;click&quot;, create the shape in a fixed location on the surface.
// If this is the end of a drag operation, place the shape on the surface at
// the current mouse position.
onMouseUp(evt) {
  if (this.isClick(evt) &amp;&amp; !(this.activeController instanceof ToolboxSurface)) {
    // Treat this as a click.
    var el = this.activeController.createElement();

    // The new shape is attached to the grid surface's mouse controller.
    var shape = this.activeController.createShape(this.mouseController, el);
    this.setShapeName(el, shape);

    // Account for surface translation (scrolling)
    shape.translate(-this.surfaceShape.X, -this.surfaceShape.Y);

    // Use the mouse controller associated with the surface.
    this.dropShapeOnSurface(SVG_OBJECTS_ID, el, shape);
    this.mouseDown = false;
  }
}</pre>
<p>Note that we prevent anything from happening if the user clicks on the 
toolbox surface itself.</p>
<p>This is the heart of the &quot;click &amp; drag&quot; behavior.&nbsp; A click is determined 
by a mouse up event occurring within a motion &quot;window.&quot;&nbsp; After that:</p>
<ul>
	<li>The &quot;real&quot; shape is created.</li>
	<li>Translated to account for surface translation.</li>
	<li>Dropped onto the surface.</li>
	<li>Cleanup.</li>
</ul>
<p>Dropping the shape onto the surface involves appending the shape to the 
&quot;objects&quot; group and telling the surface mouse controller about the shape:</p>
<pre>dropShapeOnSurface(groupName, svgElement, shapeController) {
  getElement(groupName).appendChild(svgElement);
  this.mouseController.attach(svgElement, shapeController);
}</pre>
<h4><a name="ToolboxControlleronMouseMove32">Toolbox Controller onMouseMove</a></h4>
<pre>// If the user is dragging, we create a new shape that can be dragged onto
// the surface. When the drag operation ends, the shape is transferred to the surface.
onMouseMove(evt) {
  if (this.mouseDown) {
    evt.preventDefault();
    if (this.draggingShape) {
      // Our toolbox surface picked up the event instead of the shape. Handle
      // as if the shape got the event.
      super.onMouseMove(evt);
    } else {
      // Make sure a shape has been selected rather than dragging the toolbox surface.
      if (!(this.activeController instanceof ToolboxSurface)) {
        if (!this.isClick(evt)) {
          var endDownX = evt.clientX;
          var endDownY = evt.clientY;
          var el = this.activeController.createElementAt(endDownX, endDownY);
          // Here, because we're dragging, the shape needs to be attached to both the toolbox controller and the surface's mouse controller
          // so that if the user moves the shape too quickly, either the toolbox controller or the surface controller will pick it up.
          var shape = this.activeController.createShape(this.mouseController, el);
          this.setShapeName(el, shape);
          // set the shape name so we can map shape names to shape constructors when loading a diagram.
          el.setAttributeNS(null, &quot;shapeName&quot;, shape.constructor.name);
          shape.mouseController.mouseDownX = endDownX;
          shape.mouseController.mouseDownY = endDownY + 30; // Offset so shape is drawn under mouse.
          this.createShapeForDragging(el, shape);
          this.draggingShape = true;
        }
      }
    }
  }
}</pre>
<p>This is the most complicated piece.&nbsp; The above code handles:</p>
<ul>
	<li>If the user moves the shape quickly, the toolbox surface might get the 
	event, so we handle the default behavior which is to update the shape's 
	translation.&nbsp; 
	<ul>
		<li>One caveat -- if the mouse is moving within the click window, the 
		surface mouse controller doesn't have the active shape yet, so nothing 
		happens.</li>
	</ul>
	</li>
	<li>We also don't want the user dragging the toolbox surface itself.&nbsp; 
	At least not yet.&nbsp; Maybe this will scroll the shapes in the toolbox 
	later.</li>
	<li>A drag operation begins only when the user has moved the mouse enough to 
	not be considered a click event.</li>
	<li>The shape is handed off to the <i>surface</i> mouse controller at this 
	point.</li>
</ul>
<p>When the shape is created for dragging, it is actually appended to the <i>
toolbox</i> SVG group, so it stay in the foreground while the user moves the 
shape over to the grid.&nbsp; Later we have to move the shape to the <i>object</i>s<i> 
SVG </i>group<i>.</i></p>
<pre>// Place the shape into the toolbox group so it's topmost, and attach the shape to mouse our toolbox mouse controller
// and the surface mouse controller so off-shape mouse events are handled correctly.
createShapeForDragging(el, shape) {
  // The shape is now under the control of the surface mouse controller even though we added it to our toolbox group.
  // This is because the shape wires up the surface mouse controller events.
  // The only thing the toolbox controller will see is the onMouseMove when the user moves the mouse too fast and the
  // mouse events end up being handled by the toolbox controller (or, if over the surface, the surface controller.)
  this.dropShapeOnSurface(SVG_TOOLBOX_ID, el, shape);

  // We need to know what shape is being moved, in case we (the tookbox controller) start to receive mouse move events.
  this.attach(el, shape);
  this.activeController = shape;

  // The surface mouse controller also needs to know what shape is active and that we are in the &quot;mouse down&quot; state.
  this.mouseController.activeController = shape;
  this.mouseController.mouseDown = true;
}</pre>
<p>At this point, the surface mouse controller has control!</p>
<h4><a name="MouseControlleronMouseUp33">Mouse Controller onMouseUp</a></h4>
<pre>// Any dragging is now done.
onMouseUp(evt) {
  if (evt.button == LEFT_MOUSE_BUTTON &amp;&amp; this.activeController != null) {
    evt.preventDefault();
    // Allows the toolbox controller to finish the drag &amp; drop operation.
    this.toolboxController.mouseUp();
    this.clearSelectedObject();
  }
}</pre>
<p>As stated above, the <i>surface</i> mouse controller has control of the shape 
when the drag operation begins.&nbsp; When <i>it</i> receives a mouse up event, 
it gives the toolbox controller the opportunity to finish any toolbox drag &amp; 
drop operation:</p>
<pre>// Handles end of drag &amp; drop operation, otherwise, does nothing -- toolbox item was clicked.
mouseUp() {
  if (this.draggingShape) {
    // Account for surface translation (scrolling)
    this.activeController.translate(-this.surfaceShape.X, -this.surfaceShape.Y);

    var el = this.activeController.svgElement;

    // Move element out of the toolbox group and into the objects group.
    getElement(SVG_TOOLBOX_ID).removeChild(el);
    getElement(SVG_OBJECTS_ID).appendChild(el);
    this.dragComplete(el);
  }
}</pre>
<p>Here the element is moved from the topmost foreground position (in the 
toolbox SVG group) to the objects SVG group.&nbsp; We also have to account for 
any surface translation so the shape is appears exactly where it is when the 
user concludes the drag operation.&nbsp; Lastly, we clean up the toolbox 
controller's state:</p>
<pre>dragComplete(el) {
  this.draggingShape = false;
  this.detach(el);
  this.mouseDown = false;
  this.activeController = null;
}</pre>
<pre><img border="0" src="toolbox3.png" width="532" height="363"></pre>
<p>Phew!&nbsp; All done!&nbsp; (Except maybe getting the shapes to click &amp; drop 
at more uniform location.)</p>
<h2><a name="SavingandRestoringtheDiagramLocally34">Saving and Restoring the Diagram Locally</a></h2>
<p>We have enough happening now that before doing anything else, I think it's a 
good idea to look at how shapes are saved and loaded locally.&nbsp; The 
implementation I present here is very rudimentary -- it automatically initiates 
a download which will go into the Downloads folder, and in Chrome, any existing 
file causes the filename to be appended with (n) where n is an incrementing 
number.&nbsp; At some point I will enhance this functionality using the HTML5 
FileSystem API (<a href="https://www.html5rocks.com/en/tutorials/file/filesystem/">https://www.html5rocks.com/en/tutorials/file/filesystem/</a> 
and <a href="https://dev.w3.org/2009/dap/file-system/pub/FileSystem/">
https://dev.w3.org/2009/dap/file-system/pub/FileSystem/</a>), part of the
<a href="https://developer.mozilla.org/en-US/docs/WebAPI">WebAPI</a>.&nbsp; But for now, it 
writes &quot;data.svg&quot; and on load, let's you select the directory and file.&nbsp; 
Rather than focusing on the UI for saving/loading diagrams, the point here is to 
focus on the mechanics of actually saving and loading the diagram itself.&nbsp; 
Between figuring out how to write the Javascript, working with the SVG DOM, and 
fixing bugs, this took two days!</p>
<p><img border="0" src="saveload1.png" width="422" height="182"></p>
<p>To begin with, I added Save and Load buttons at the top of the page:</p>
<pre>&lt;div&gt;
  &lt;!-- <a href="https://stackoverflow.com/questions/1944267/how-to-change-the-button-text-of-input-type-file%20--">https://stackoverflow.com/questions/1944267/how-to-change-the-button-text-of-input-type-file --</a>&gt;
  &lt;!-- creates a hidden file input on routes the button to clicking on that tag --&gt;
  &lt;button onclick=&quot;saveSvg()&quot;&gt;Save&lt;/button&gt;
  &lt;button onclick=&quot;document.getElementById('fileInput').click();&quot;&gt;Load&lt;/button&gt;
  &lt;input type=&quot;file&quot; id=&quot;fileInput&quot; style=&quot;display:none;&quot;/&gt;
&lt;/div&gt;</pre>
<p>The trick here, to avoid the default behavior of a file input element, was to 
hide the input element, as to SO link showed me.</p>
<h3><a name="SavingtheDiagram35">Saving the Diagram</a></h3>
<p>Saving the SVG <i>locally</i> took some research and resulted n this code:</p>
<pre>document.getElementById(FILE_INPUT).addEventListener('change', readSingleFile, false);</pre>
<pre>// https://stackoverflow.com/questions/23582101/generating-viewing-and-saving-svg-client-side-in-browser
function saveSvg() {
  var svg = getElement(SVG_OBJECTS_ID);
  // <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLSerializer">https://developer.mozilla.org/en-US/docs/Web/API/XMLSerializer</a>
  var serializer = new XMLSerializer();
  var xml = serializer.serializeToString(svg);
  // Prepend the xml with other things we want to save, like the surface translation and grid spacing.
  xml = &quot;&lt;diagram&gt;&quot; + surface.serialize() + &quot;&lt;/diagram&gt;&quot; + xml;
  var blob = new Blob([xml], { 'type': &quot;image/svg+xml&quot; });

  // We're using <a href="https://github.com/eligrey/FileSaver.js/">https://github.com/eligrey/FileSaver.js/</a>
  // but with the &quot;export&quot; (a require node.js thing) removed.
  // There are several forks of this, not sure if there's any improvements in the forks.
  saveAs(blob, FILENAME);
}</pre>
<p>As the comments point out, I'm using FileSaver.js, written by &quot;eligrey.&quot;&nbsp; 
Thank goodness for open source -- this works in Chrome and Edge (the two 
browsers I tested) and has support for other browser's nuances as well.&nbsp; Of 
particular note here:</p>
<ul>
	<li>We're giving the surface (and maybe other objects later on) the 
	opportunity to save their state.&nbsp; The surface needs to save:<ul>
		<li>It's translation.</li>
		<li>The grid spacing.</li>
	</ul>
</li>
	<li>This data, as an XML string, is prepended to the SVG data.</li>
</ul>
<p>In the surface class, this is implemented as:</p>
<pre>// Create an XML fragment for things we want to save here.
serialize() {
  var el = document.createElement(&quot;surface&quot;);
  // DOM adds elements as lowercase, so let's just start with lowercase keys.
  var attributes = {x : this.X, y : this.Y, gridcellw : this.gridCellW, gridcellh : this.gridCellH, 
                    cellw : this.cellW, cellh : this.cellH}
  Object.entries(attributes).map(([key, val]) =&gt; el.setAttribute(key, val));
  var serializer = new XMLSerializer();
  var xml = serializer.serializeToString(el);

  return xml;
}</pre>
<p>That was the easy part -- the file is <i>downloaded</i> into the browser's 
default download location.</p>
<h3><a name="LoadingtheDiagram36">Loading the Diagram</a></h3>
<p>The first step is to actually read the file data locally:</p>
<pre>// https://w3c.github.io/FileAPI/
// https://stackoverflow.com/questions/3582671/how-to-open-a-local-disk-file-with-javascript
// Loading the file after it has been loaded doesn't trigger this event again because it's
// hooked up to &quot;change&quot;, and the filename hasn't changed!
function readSingleFile(e) {
  var file = e.target.files[0];
  var reader = new FileReader();
  reader.onload = loadComplete;
  reader.readAsText(file);
  // Clears the last filename(s) so loading the same file will work again.
  document.getElementById(FILE_INPUT).value = &quot;&quot;;
}</pre>
<p>This function uses the WebAPI's <code>FileReader</code> class.&nbsp; The most 
interesting thing here is clearing the filename from the input element.&nbsp; As 
the comment points out, if we don't do this, we can't re-load the diagram if it 
has the same filename.&nbsp; Very annoying for testing.</p>
<p>When the load completes (I didn't implement any error checking / validation 
that the file is actually a diagram file):</p>
<pre>function loadComplete(e) {
  var contents = e.target.result;
  var endOfDiagramData = contents.indexOf(END_OF_DIAGRAM_TAG);
  var strDiagram = contents.substr(0, endOfDiagramData).substr(START_OF_DIAGRAM_TAG.length);
  var xmlDiagram = stringToXml(strDiagram);
  // Deserialize the diagram's surface XML element to restore grid spacing and grid translation.
  surface.deserialize(xmlDiagram);
  var svgData = contents.substr(endOfDiagramData + END_OF_DIAGRAM_TAG.length)
  replaceObjects(contents);
}</pre>
<p>Several things happen:</p>
<ul>
	<li>The data (as a string) is separated out into the diagram &quot;state&quot; 
	information -- currently just the surface state -- and the SVG data.</li>
<li>The surface state is restored.</li>
	<li>The &quot;objects&quot; element is replaced.</li>
</ul>
<p>The surface state is deserialized and restored:</p>
<pre>// Deserialize the xml fragment that contains the surface translation and grid dimensions on a file load.
deserialize(xml) {
  var obj = xmlToJson(xml);
  var attributes = obj.surface.attributes;
  // Note the attributes, because they were serialized by the DOM, are all lowercase.
  // OK to assume all ints?
  this.X = parseInt(attributes.x);
  this.Y = parseInt(attributes.y);
  this.gridCellW = parseInt(attributes.gridcellw);
  this.gridCellH = parseInt(attributes.gridcellh);
  this.cellW = parseInt(attributes.cellw);
  this.cellH = parseInt(attributes.cellh);
  var dx = this.X % this.gridCellW;
  var dy = this.Y % this.gridCellH;
  this.resizeGrid(this.gridCellW, this.gridCellH, this.cellW, this.cellH);
  this.svgElement.setAttribute(&quot;transform&quot;, &quot;translate(&quot; + dx + &quot;,&quot; + dy + &quot;)&quot;);
}</pre>
<p>The deserializer xmlToJson was found at the link in the comments.&nbsp; I 
made a minor tweak to the code described in that link:</p>
<pre>function stringToXml(xmlStr) {
  // <a href="https://stackoverflow.com/a/3054210/2276361">https://stackoverflow.com/a/3054210/2276361</a>
  return (new window.DOMParser()).parseFromString(xmlStr, &quot;text/xml&quot;);
}

// https://davidwalsh.name/convert-xml-json
function xmlToJson(xml) {
  var obj = {};

  if (xml.nodeType == 1) { // element
  // do attributes
    if (xml.attributes.length &gt; 0) {
      obj[&quot;attributes&quot;] = {};

      for (var j = 0; j &lt; xml.attributes.length; j++) {
        var attribute = xml.attributes.item(j);
        obj[&quot;attributes&quot;][attribute.nodeName] = attribute.nodeValue;
      }
   }
  } else if (xml.nodeType == 3) { // text
    obj = xml.nodeValue;
  }

  // do children
  if (xml.hasChildNodes()) {
    for(var i = 0; i &lt; xml.childNodes.length; i++) {
      var item = xml.childNodes.item(i);
      var nodeName = item.nodeName;

      if (typeof(obj[nodeName]) == &quot;undefined&quot;) {
        obj[nodeName] = xmlToJson(item);
      } else {
        if (typeof(obj[nodeName].push) == &quot;undefined&quot;) {
          var old = obj[nodeName];
          obj[nodeName] = [];
          obj[nodeName].push(old);
        }

      obj[nodeName].push(xmlToJson(item));
      }
    }
  }

  return obj;
};</pre>
<p>Next, the &quot;objects&quot; element is replaced.&nbsp; To do this, I wrapped the 
&quot;objects&quot; element in an group so that the child element of the wrapping group 
can be manipulated.</p>
<pre>&lt;!-- Also, we create an outer group so that on file load, we can remove
     the &quot;objectGroup&quot; and replace it with what got loaded. --&gt;
&lt;g id=&quot;objectGroup&quot;&gt;
  &lt;g id=&quot;objects&quot; transform=&quot;translate(0, 0)&quot;&gt;&lt;/g&gt;
&lt;/g&gt;</pre>
<p>The Javascript code:</p>
<pre>// Replace &quot;objects&quot; with the contents of what got loaded.
function replaceObjects(contents) {
  mouseController.destroyAllButSurface();
  var objectGroup = getElement(OBJECT_GROUP_ID);
  var objects = getElement(SVG_OBJECTS_ID);
  objectGroup.removeChild(objects);
  // <a href="https://stackoverflow.com/questions/38985998/insert-svg-string-element-into-an-existing-svg-tag">https://stackoverflow.com/questions/38985998/insert-svg-string-element-into-an-existing-svg-tag</a>
  objectGroup.innerHTML = contents;
  createShapeControllers();
  // re-acquire the objects element after adding the contents.
  var objects = getElement(SVG_OBJECTS_ID);
  surface.svgObjects = objects;
}</pre>
<p>Several things happen in order to replace the &quot;objects&quot; element:</p>
<ul>
	<li>All objects except the &quot;surface&quot; currently on the surface are &quot;destroyed.&quot;&nbsp; This means 
	that:<ul>
		<li>Their events are unwired.</li>
		<li>They are detached from the mouse controller.</li>
	</ul>
	</li>
	<li>The child &quot;objects&quot; element is removed.</li>
	<li>The outer group's inner HTML is replaced with the SVG data that was 
	loaded from the file.</li>
	<li>Next, the backing shape controller classes need to be 
	instantiated.&nbsp; This means:<ul>
		<li>Wiring up their events.</li>
		<li>Attaching them to the mouse controller.</li>
		<li>Fixing up their position so the object knows how they've been 
		translated.</li>
	</ul>
	</li>
	<li>Lastly:<ul>
		<li>The new &quot;objects&quot; element is acquired.</li>
		<li>The surface controller is told about the new &quot;objects&quot; element.</li>
	</ul>
</li>
</ul>
<p>Why are we destroying all SVG elements except the &quot;surface&quot; element?&nbsp; 
The surface element is effectively our placeholder element for the grid and 
handles the scrolling of the surface.&nbsp; We don't need to replace that 
element, so we ignore it:</p>
<pre>destroyAllButSurface() {
  Object.entries(this.controllers).map(([key, val]) =&gt; {
    if (!(val instanceof Surface)) {
      val.destroy();
    }
  });
}</pre>
<p>Creating the shape controllers is done with a lookup to map the <code>shapename</code> 
attribute to the function that instantiates the correct shape controller:</p>
<pre>var elementNameShapeMap = {
  Rectangle: (mouseController, svgElement) =&gt; new Rectangle(mouseController, svgElement),
  Circle: (mouseController, svgElement) =&gt; new Circle(mouseController, svgElement),
  Diamond: (mouseController, svgElement) =&gt; new Diamond(mouseController, svgElement)
};
</pre>
<p>As an aside, where did the <code>shapename</code> attribute come from?&nbsp; 
This is created when the shape is click &amp; dropped or drag &amp; dropped by the 
toolbox.&nbsp; In the <code>ToolboxController</code> class:</p>
<pre>setShapeName(el, shape) {
  // set the shape name so we can map shape names to shape constructors when loading a diagram.
  // <a href="https://stackoverflow.com/questions/1249531/how-to-get-a-javascript-objects-class">https://stackoverflow.com/questions/1249531/how-to-get-a-javascript-objects-class</a>
  el.setAttributeNS(null, SHAPE_NAME_ATTR, shape.constructor.name);
}
</pre>
<p>Also, in the <code>SvgToolboxElement</code> class, we add a class attribute that makes it easy to get 
all the SVG elements in the &quot;objects&quot; group:</p>
<pre>// Create a class common to all shapes so that, on file load, we can get them all and re-attach them
// to the mouse controller.
el.setAttributeNS(null, &quot;class&quot;, SHAPE_CLASS_NAME);</pre>
<p>Javascript for creating the shape controllers:</p>
<pre>// The difficult part -- creating the shape controller based on the element's shapeName attribute to the shape controller class counterpart.
function createShapeControllers() {
  var els = getElements(SHAPE_CLASS_NAME);

  for (let el of els) { // note usage &quot;of&quot; - ES6. note usage &quot;let&quot; : scope limited to block.
    let shapeName = el.getAttribute(SHAPE_NAME_ATTR);
    let creator = elementNameShapeMap[shapeName];
    let shape = creator(mouseController, el);
    // Annoyingly, we DO have to parse the translation to set the X and Y properties of the shape!
    let transform = el.getAttribute(&quot;transform&quot;);
    let transforms = parseTransform(transform);
    let translate = transforms[&quot;translate&quot;];
    // We assume integers?
    shape.X = parseInt(translate[0]);
    shape.Y = parseInt(translate[1]);
  }
}</pre>
<p>Annoyingly, we have to actually parse the transform because I don't add 
attributes to the SVG element for the shape controller.&nbsp; This is done using some code 
I found on SO:</p>
<pre>// https://stackoverflow.com/questions/17824145/parse-svg-transform-attribute-with-javascript
function parseTransform(transform) {
  var transforms = {};
  for (var i in a = transform.match(/(\w+\((\-?\d+\.?\d*e?\-?\d*,?)+\))+/g)) {
    var c = a[i].match(/[\w\.\-]+/g);
    transforms[c.shift()] = c;
  }

  return transforms;
}</pre>
<p>We now have a simple mechanism for saving and loading a diagram.&nbsp; When 
new shapes are added, only the <code>elementNameShapeMap</code> needs to be updated.</p>

<h2><a name="LinesandAnchorPoints37">Lines and Anchor Points</a></h2>
<p>The last thing I want to create for this article is the ability to draw 
simple lines that can connect shapes.&nbsp; Easier said than done, as this means 
we will need some additional diagram state information so that we know what 
lines are attached to what shapes so that when the shape moves, the line is 
updated as well.&nbsp; I'm not even going to deal with
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">
arrows</a> yet!</p>
<h3><a name="TheComplexitiesofSelectingALine38">The Complexities of Selecting A Line</a></h3>
<p>After creating the <code>Line</code> and <code>ToolboxLine</code> classes following the same template as the other 
shape controller classes, adding a line element to the toolbox 
group and wiring up the shape controller:</p>
<pre>&lt;line id=&quot;toolboxLine&quot; x1=&quot;10&quot; y1=&quot;70&quot; x2=&quot;50&quot; y2=&quot;110&quot; stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;#FFFFFF&quot; /&gt;

new ToolboxLine(toolboxController, getElement(TOOLBOX_LINE_ID));</pre>
<p>we encounter the first problem -- it's nearly impossible to actually select 
the line because the line is so thin -- you have to click exactly on the pixels 
of the line in order to select it.&nbsp; The best solution to this issue seems 
to be to create a group with two lines: the actual line and a transparent line 
with a larger width (<a href="https://stackoverflow.com/a/9126498/2276361">reference</a>.)&nbsp; 
This is what we want to do once the shape is on the drawing, but for the 
toolbox, we don't want the user to have to be that precise, so instead we'll 
create a transparent rectangle so that visually, anywhere in the &quot;box&quot; formed by 
the toolbox line shape will work.&nbsp; Back to the toolbox group:</p>
<p><img border="0" src="line1.png" width="422" height="249"></p>
<p>This works quite well (the commented out transparent line is for future 
reference):</p>
<pre>&lt;g id=&quot;toolboxLine&quot;&gt;
  &lt;line id=&quot;line&quot; x1=&quot;10&quot; y1=&quot;70&quot; x2=&quot;50&quot; y2=&quot;110&quot; stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;#FFFFFF&quot; /&gt;
  &lt;rect id=&quot;hiddenLine&quot; x=&quot;10&quot; y=&quot;70&quot; width=&quot;40&quot; height=&quot;40&quot; stroke=&quot;black&quot; stroke-opacity=&quot;0&quot; fill-opacity=&quot;0&quot;/&gt;
  &lt;!--&lt;line id=&quot;line2&quot; x1=&quot;10&quot; y1=&quot;70&quot; x2=&quot;50&quot; y2=&quot;110&quot; fill=&quot;#FFFFFF&quot; stroke-opacity=&quot;0&quot; fill-opacity=&quot;0&quot;/&gt;--&gt;
&lt;/g&gt;</pre>
<p>While we're at it, we can anticipate the next problem -- clicking and 
dragging the line's endpoints so that it's easier to change the line's length 
and orientation.&nbsp; Let's look at how this group is rendered:</p>
<pre>&lt;g id=&quot;toolboxLine&quot;&gt;
  &lt;rect id=&quot;hiddenLine&quot; x=&quot;10&quot; y=&quot;70&quot; width=&quot;40&quot; height=&quot;40&quot; stroke=&quot;black&quot; stroke-opacity=&quot;0&quot; fill-opacity=&quot;0&quot;/&gt;
  &lt;line id=&quot;line2&quot; x1=&quot;10&quot; y1=&quot;70&quot; x2=&quot;50&quot; y2=&quot;110&quot; fill=&quot;#FFFFFF&quot; stroke=&quot;black&quot; stroke-width=&quot;20&quot;/&gt;
  &lt;line id=&quot;line&quot; x1=&quot;10&quot; y1=&quot;70&quot; x2=&quot;50&quot; y2=&quot;110&quot; stroke=&quot;red&quot; stroke-width=&quot;1&quot; fill=&quot;#FFFFFF&quot; /&gt;
&lt;/g&gt;</pre>
<p><img border="0" src="line2.png" width="74" height="69"></p>
<p>Notice that the stroke width doesn't cause the larger line to extend beyond 
the extents of the red line with stroke width 1.&nbsp; From a UI perspective, 
this means that the user would have to select a line endpoint by being &quot;inside&quot; 
the line -- selecting the line endpoint near the &quot;outside&quot; won't result in the 
mouse events being handled by the line.&nbsp; Again, we can fix this by creating 
transparent rectangles around the line endpoints which will represent the 
clickable area for selecting a line endpoint.&nbsp; When rendered without 
transparency, we get this -- the red areas are the clickable areas to select the 
shape in the toolbox and to select the endpoints once the line has been drawn on 
the surface:</p>
<p><img border="0" src="line3.png" width="64" height="61"></p>
<pre>&lt;g id=&quot;toolboxLine&quot;&gt;
  &lt;rect id=&quot;lineHiddenSelectionArea&quot; x=&quot;10&quot; y=&quot;70&quot; width=&quot;40&quot; height=&quot;40&quot; stroke=&quot;red&quot; stroke-width=&quot;1&quot; fill=&quot;#FFFFFF&quot;/&gt; 
  &lt;rect id=&quot;endpoint1&quot; transform=&quot;translate(10, 70)&quot; x=&quot;-5&quot; y=&quot;-5&quot; width=&quot;10&quot; height=&quot;10&quot; stroke=&quot;red&quot; stroke-width=&quot;1&quot; fill=&quot;#FFFFFF&quot;/&gt;
  &lt;rect id=&quot;endpoint2&quot; transform=&quot;translate(50, 110)&quot; x=&quot;-5&quot; y=&quot;-5&quot; width=&quot;10&quot; height=&quot;10&quot; stroke=&quot;red&quot; stroke-width=&quot;1&quot; fill=&quot;#FFFFFF&quot; /&gt;
  &lt;line id=&quot;line&quot; x1=&quot;10&quot; y1=&quot;70&quot; x2=&quot;50&quot; y2=&quot;110&quot; fill=&quot;#FFFFFF&quot; stroke=&quot;black&quot; stroke-width=&quot;1&quot; /&gt;
&lt;/g&gt;</pre>
<p>In reality, when creating a line on the surface, we'll deal with anchors 
slightly differently rather than adding them to the &quot;toolboxLine&quot; group.</p>
<ul>
	<li>For the toolbox, we don't need to the endpoint rectangles or the larger 
	transparent stroke line.</li>
	<li>For the line when it's on the diagram surface, we need to endpoint 
	rectangles and the larger transparent stroke line for easy selection by the 
	mouse.<ul>
	<li>In reality, when creating a line on the surface, we'll deal with anchors 
	slightly differently rather than adding them to the &quot;toolboxLine&quot; group, as 
	described in the next section.</li>
</ul>
	</li>
</ul>
<p>This means that we have some specialized work to do when creating the element 
when it is dropped onto the surface (showing only the <code>createElement</code> function):</p>
<pre>createElement() {
  var el = super.createElement('g', {});
  el.appendChild(super.createChildElement('line', { x1: 240, y1: 100, x2: 300, y2: 160, &quot;stroke-width&quot;: 20, stroke: &quot;black&quot;, &quot;stroke-opacity&quot;: &quot;0&quot;, &quot;fill-opacity&quot;: &quot;0&quot; }));
  el.appendChild(super.createChildElement('line', { x1: 240, y1: 100, x2: 300, y2: 160, fill: &quot;#FFFFFF&quot;, stroke: &quot;black&quot;, &quot;stroke-width&quot;: 1 }));

  return el;
}</pre>
<p>Of note here is something important:</p>
<ul>
	<li>The stroke &quot;color&quot; must be initialized in the transparent line, 
	otherwise the outer group does not include it in its region and the wider 
	transparent line is not selectable!</li>
</ul>
<p>I also had to write a <code>createChildElement</code> function which differs from 
<code>createElement</code> only in that it does not create a <code>class</code> attribute, as we don't 
want these child elements to be mapped to the shape controllers -- only the outer group.</p>
<p><img border="0" src="line4.png" width="175" height="141"></p>
<p>We can now click &amp; drop and drag &amp; drop a line onto the surface and then drag 
the line around.</p>
<h3><a name="PointClassandShapeRectangle39">Point Class and Shape Rectangle</a></h3>
<p>At this point, I'm going to digress briefly -- it's time to create a Point 
class and functions that help us get the diagonal corners of a shape.&nbsp; Each 
shape has nuances.&nbsp; Lines have (x1,y1) and (x2,y2) attributes, rectangles 
have (x, y) and (width, height) attributes, circles have (cx, cy) and (r) 
attributes and paths, well, having a bounding rectangle.&nbsp; I want to unify 
this mess.&nbsp; We'll define a simple Point class:</p>
<pre>class Point {
  constructor(x, y) {
    this.X = x;
    this.Y = y;
  }

  translate(x, y) {
    this.X += x;
    this.Y += y;

    return this;
  }
}</pre>
<p>Yes, there's already an
<a href="https://developer.mozilla.org/en-US/docs/Web/API/SVGPoint">SVGPoint</a> 
object as well as a
<a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMPoint">DOMPoint</a> 
object, but I'm not using either, as I want behaviors, like translate, that 
these objects don't provide.</p>
<p>Now we can implement getting the upper left and lower right corners for each 
shape, <i>translated</i> to the absolute coordinate of the shape.</p>
<p>Rectangle:</p>
<pre>getULCorner() {
  var p = new Point(+this.svgElement.getAttribute(&quot;x&quot;), +this.svgElement.getAttribute(&quot;y&quot;));
  p = this.getAbsoluteLocation(p);

  return p;
}
</pre>
<pre>getLRCorner() {
  var p = new Point(+this.svgElement.getAttribute(&quot;x&quot;) + +this.svgElement.getAttribute(&quot;width&quot;), 
                    +this.svgElement.getAttribute(&quot;y&quot;) + +this.svgElement.getAttribute(&quot;height&quot;));
  p = this.getAbsoluteLocation(p);

  return p;
}</pre>
<p>Circle:</p>
<pre>getULCorner() {
  var p = new Point(+this.svgElement.getAttribute(&quot;cx&quot;) - +this.svgElement.getAttribute(&quot;r&quot;),
                    +this.svgElement.getAttribute(&quot;cy&quot;) - +this.svgElement.getAttribute(&quot;r&quot;));
  p = this.getAbsoluteLocation(p);

  return p;
}

getLRCorner() {
  var p = new Point(+this.svgElement.getAttribute(&quot;cx&quot;) + +this.svgElement.getAttribute(&quot;r&quot;), 
                    +this.svgElement.getAttribute(&quot;cy&quot;) + +this.svgElement.getAttribute(&quot;r&quot;));
  p = this.getAbsoluteLocation(p);

  return p;
}</pre>
<p>Line:</p>
<pre>getULCorner() {
  var line = this.svgElement.children[0];
  var p = new Point(+line.getAttribute(&quot;x1&quot;), +line.getAttribute(&quot;y1&quot;));
  p = this.getAbsoluteLocation(p);

  return p;
}

getLRCorner() {
  var line = this.svgElement.children[0];
  var p = new Point(+line.getAttribute(&quot;x2&quot;), +line.getAttribute(&quot;y2&quot;));
  p = this.getAbsoluteLocation(p);

  return p;
}</pre>
<p>Diamond:</p>
<p>Paths are interesting because <code>getBoundingClientRect</code> returns the shape's 
location <i>already translated</i>.&nbsp; As the function name indicates, the 
returns the client (in screen coordinates) location, so we have to translate it 
to the root SVG element's location.</p>
<pre>getULCorner() {
  var rect = this.svgElement.getBoundingClientRect();
  var p = new Point(rect.left, rect.top);
  this.translateToSvgCoordinate(p);

  return p;
}

getLRCorner() {
  var rect = this.svgElement.getBoundingClientRect();
  var p = new Point(rect.right, rect.bottom);
  this.translateToSvgCoordinate(p);

  return p;
}</pre>
<p>And for the two helper functions:</p>
<pre>getAbsoluteLocation(p) {
  p.translate(this.X, this.Y);
  p.translate(this.mouseController.surface.X, this.mouseController.surface.Y);

  return p;
}

// https://stackoverflow.com/questions/22183727/how-do-you-convert-screen-coordinates-to-document-space-in-a-scaled-svg
translateToSvgCoordinate(p) {
  var svg = document.getElementById(SVG_ELEMENT_ID);
  var pt = svg.createSVGPoint();
  var offset = pt.matrixTransform(svg.getScreenCTM().inverse());
  p.translate(offset.x, offset.y);
}</pre>
<h2><a name="Anchors40">Anchors</a></h2>
<p>Next, we want to be able to change the line length and its orientation.&nbsp; 
This will be a useful exercise as the behavior is similar to resizing a shape.&nbsp; 
In WinForm app <a href="https://www.codeproject.com/Articles/1136050/FlowSharp">
FlowSharp</a>, I had each shape determine the anchor points for sizing.&nbsp; 
We'll do the same thing here.&nbsp; We finally have something to implement in 
the shape's controller classes!&nbsp; The idea here is that when the mouse hovers 
over a shape, the anchors magically appear so the user has an indication of 
where to click &amp; drag to modify the shape.&nbsp; In the mouse controller, we'll 
add an <code>onMouseOver</code> event handler and add it to the events that get 
wired up in the shape's controller <code>SvgElement</code> base class:</p>
<pre>this.registerEventListener(svgElement, &quot;mouseover&quot;, mouseController.onMouseOver, mouseController);</pre>
<p>The event handler:</p>
<pre>onMouseOver(evt) {
  var id = evt.currentTarget.getAttribute(&quot;id&quot;);
  var hoverShape = this.controllers[id];
  
  // On drag &amp; drop, anchors are not shown because of this first test.
  // We do this test so that if the user moves the mouse quickly, we don't
  // re-initialize the anchors when the shape catches up (resulting in
  // a mousemove event again.
  if (this.activeController == null) {
    if (hoverShape instanceof SvgElement &amp;&amp;
        !(hoverShape instanceof ToolboxController) &amp;&amp;
        !(hoverShape instanceof Surface)) {
      this.displayAnchors(hoverShape);
    } else {
      this.removeAnchors();
    this.anchors = [];
    }
  }
}

displayAnchors(hoverShape) {
  var anchors = hoverShape.getAnchors();
  this.showAnchors(anchors);
  this.anchors = anchors;
}</pre>
<p>Anchors will be displayed between the &quot;objects&quot; and &quot;toolbox&quot; groups, so that 
anchors are on top of every other shape but below the toolbox:</p>
<pre>&lt;g id=&quot;objectGroup&quot;&gt;
  &lt;g id=&quot;objects&quot; transform=&quot;translate(0, 0)&quot;&gt;&lt;/g&gt;
&lt;/g&gt;
&lt;g id=&quot;anchors&quot;&gt;&lt;/g&gt;
&lt;g id=&quot;toolbox&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;200&quot; height=&quot;480&quot;&gt;
...</pre>
<p>Creating anchors:</p>
<pre>showAnchors(anchors) {
  // not showing?
  if (this.anchors.length == 0) {
    var anchorGroup = getElement(ANCHORS_ID);
    // Reset any translation because the next mouse hover will set the anchors directly over the shape.
    anchorGroup.setAttribute(&quot;transform&quot;, &quot;translate(0, 0)&quot;);

    anchors.map(anchor =&gt; {
      var el = this.createElement(&quot;rect&quot;, 
        { x: anchor.X - 5, y: anchor.Y - 5, width: 10, height: 10, 
          fill: &quot;#FFFFFF&quot;, stroke: &quot;black&quot;, &quot;stroke-width&quot;: 0.5});
      anchorGroup.appendChild(el);
    });
  }
}

// TODO: Very similar to SvgToolboxElement.createElement. Refactor for common helper class?
createElement(name, attributes) {
  var svgns = &quot;<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>&quot;;
  var el = document.createElementNS(svgns, name);
  el.setAttribute(&quot;id&quot;, Helpers.uuidv4());
  Object.entries(attributes).map(([key, val]) =&gt; el.setAttributeNS(null, key, val));

  return el;
}</pre>
<p>Removing anchors:</p>
<pre>removeAnchors() {
  // already showing?
  if (this.anchors.length &gt; 0) {
    var anchorGroup = getElement(ANCHORS_ID);

    // <a href="https://stackoverflow.com/questions/3955229/remove-all-child-elements-of-a-dom-node-in-javascript">https://stackoverflow.com/questions/3955229/remove-all-child-elements-of-a-dom-node-in-javascript</a>
    // Will change later.
    anchorGroup.innerHTML = &quot;&quot;;
    // Alternatively:
    //while (anchorGroup.firstChild) {
    // anchorGroup.removeChild(anchorGroup.firstChild);
    //}
  }
}</pre>
<p>Notice the resetting of the anchor group translation above in <code>showAnchors</code> 
when the anchors are first drawn.&nbsp; One touch-up is that we now also need to translate the anchors group when the 
object is being dragged in the <code>SvgElement</code> class:</p>
<pre>onDrag(evt) {
  this.updatePosition(evt);
  this.svgElement.setAttribute(&quot;transform&quot;, &quot;translate(&quot; + this.X + &quot;,&quot; + this.Y + &quot;)&quot;);
  getElement(ANCHORS_ID).setAttribute(&quot;transform&quot;, &quot;translate(&quot; + this.X + &quot;,&quot; + this.Y + &quot;)&quot;);
  getElement(ANCHORS_ID).setAttribute(&quot;transform&quot;, &quot;translate(&quot; + this.dragX + &quot;,&quot; + this.dragY + &quot;)&quot;);
}</pre>
<p>The <code>dragX</code> and <code>dragY</code> coordinates are reset on the mouse down event in the 
<code>MouseController</code>:</p>
<pre>onMouseDown(evt) {
  if (evt.button == LEFT_MOUSE_BUTTON) {
    evt.preventDefault();
    var id = evt.currentTarget.getAttribute(&quot;id&quot;);
    this.activeController = this.controllers[id];
    this.mouseDown = true;
    this.mouseDownX = evt.clientX;
    this.mouseDownY = evt.clientY;
    this.startDownX = evt.clientX;
    this.startDownY = evt.clientY;
    this.activeController.startMove();  // &lt;----- added this
  }
}
</pre>
<p>We do this because the anchor group always begins with a translation of (0,0) 
so we need to know the translation relative to the current drag operation.&nbsp; 
There's two more nuances:</p>
<ul>
	<li>Because the user can move the mouse quickly (off the shape), the <code>mouseover</code> event will re-fire 
	(the mouse leaves the shape and when the shape catches up, the <code>mouseover</code> 
	event is fired again.)&nbsp; For this reason we check to see if there's an 
	active shape controller (a shape is actually being dragged), which is set when the user clicks down on a shape.&nbsp; 
	The side-effect to this is actually a nice one -- the anchor points are not 
	shown when the shape is drag &amp; dropped from the toolbox because the surface 
	mouse controller has an active shape controller. </li>
	<li>However, this has the unintentional side-effect of not showing the 
	anchors when the shape is dropped after a drag &amp; drop operation and the 
	mouse is still over the just-dropped shape.</li>
</ul>
<p>To fix the second problem, the toolbox controller must initiate the display 
of the anchors once the shape is dropped after a drag &amp; drop operation:</p>
<pre>dragComplete(el) {
  this.draggingShape = false;
  this.detach(el);
  this.mouseDown = false;
  this.mouseController.displayAnchors(this.activeController); // &lt;--- I added this line
  this.activeController = null;
}</pre>
<p><img border="0" src="anchors1.png" width="266" height="129"> </p>
<p><img border="0" src="anchors2.png" width="260" height="128"></p>
<p>Shapes now have anchors!&nbsp; We also have the visual side-effect of now 
showing the user what shape is about to be selected if the user wants to drag 
the shape.</p>
<h3><a name="LineLengthandOrientation41">Line Length and Orientation</a></h3>
<p>Now that we have anchors displaying, we have to get the anchors working.&nbsp; 
We'll focus on the line shape.&nbsp; Notice in the above picture that the anchor 
is drawn on top of the line.&nbsp; This helps us select the anchor for dragging 
rather than the entire line.&nbsp; If the line was on top of the anchor it would 
be possible for the user to click exactly on the line, missing the anchor.</p>
<p>To begin with, we need to be able to specify the function that is called when 
the anchor is moved.&nbsp; This is a change in the anchors array that is passed 
back to the mouse controller when displaying anchors:</p>
<pre>getAnchors() {
  var corners = this.getCorners(); 
  var anchors = [{ anchor: corners[0], onDrag: this.moveULCorner.bind(this) }, 
                 { anchor: corners[1], onDrag: this.moveLRCorner.bind(this) }];

  return anchors;
}</pre>
<ul>
	<li>Notice the <code>bind</code>, so that the &quot;this&quot; in the event handler function is the 
	<code>Line</code> 
object.&nbsp; Sigh.</li>
</ul>
<p>The Line class implements the handlers (notice the extra anchor parameter 
which I discuss shortly):</p>
<pre>// Move the (x1, y1) coordinate.
moveULCorner(anchor, evt) {
  // Use movementX and movementY - this is much better than dealing with the base class X or dragX stuff.
  // Do both the transparent line and the visible line.
  this.moveLine(&quot;x1&quot;, &quot;y1&quot;, this.svgElement.children[0], evt.movementX, evt.movementY);
  this.moveLine(&quot;x1&quot;, &quot;y1&quot;, this.svgElement.children[1], evt.movementX, evt.movementY);
  this.moveAnchor(anchor, evt.movementX, evt.movementY);
}

// Move the (x2, y2) coordinate.
moveLRCorner(anchor, evt) {
  this.moveLine(&quot;x2&quot;, &quot;y2&quot;, this.svgElement.children[0], evt.movementX, evt.movementY);
  this.moveLine(&quot;x2&quot;, &quot;y2&quot;, this.svgElement.children[1], evt.movementX, evt.movementY);
  this.moveAnchor(anchor, evt.movementX, evt.movementY);
}

moveLine(ax, ay, line, dx, dy) {
  var x1 = +line.getAttribute(ax) + dx;
  var y1 = +line.getAttribute(ay) + dy;
  line.setAttribute(ax, x1);
  line.setAttribute(ay, y1);
}</pre>
<p>Notice that we have to move both the transparent line and the visible line.&nbsp; </p>
<ul>
	<li>At this point in the coding I learned about the <code>movementX</code> and <code>movementY</code> 
	properties of the event, which if I'd known about earlier would have changed 
	how I had implemented some of the other code!</li>
</ul>
<p>The <code>moveAnchor</code> function will be common to all shapes, so it lives in the 
<code>SvgElement</code> base class:</p>
<pre>moveAnchor(anchor, dx, dy) {
  var tx = +anchor.getAttribute(&quot;tx&quot;) + dx;
  var ty = +anchor.getAttribute(&quot;ty&quot;) + dy;
  anchor.setAttribute(&quot;transform&quot;, &quot;translate(&quot; + tx + &quot;,&quot; + ty + &quot;)&quot;);
  anchor.setAttribute(&quot;tx&quot;, tx);
  anchor.setAttribute(&quot;ty&quot;, ty);
}
</pre>
<p>Next, we need an actual <code>Anchor</code> shape class:</p>
<pre>class Anchor extends SvgObject {
  constructor(anchorController, svgElement, onDrag) {
    super(anchorController, svgElement);
    this.wireUpEvents(svgElement);
    this.onDrag = onDrag;
  }

  wireUpEvents(svgElement) {
    // The mouse controller is actually the derived anchor controller.
    this.registerEventListener(svgElement, &quot;mousedown&quot;, this.mouseController.onMouseDown, this.mouseController);
    this.registerEventListener(svgElement, &quot;mousemove&quot;, this.mouseController.onMouseMove, this.mouseController);
    this.registerEventListener(svgElement, &quot;mouseup&quot;, this.mouseController.onMouseUp, this.mouseController);
    this.registerEventListener(svgElement, &quot;mouseleave&quot;, this.mouseController.onMouseLeave, this.mouseController);
  }
}</pre>
<p>Again, in order to deal with mouse events being received by the surface when 
the anchor is dragged &quot;too fast&quot;, the <code>AnchorController</code> spoofs the surface mouse 
controller into thinking (correctly so) that it's moving an anchor element:</p>
<pre>class AnchorController extends MouseController {
  constructor(mouseController) {
    super();
    // For handling dragging an anchor but the surface or shape gets the mousemove events.
    this.mouseController = mouseController;
  }

  onMouseDown(evt) {
    super.onMouseDown(evt);
    // For handling dragging an anchor but the surface or shape gets the mousemove events.
    this.mouseController.mouseDown = true;
    this.mouseController.activeController = this.activeController;
  }

  onMouseUp(evt) {
    super.onMouseUp(evt);
    // For handling dragging an anchor but the surface or shape gets the mousemove events.
    this.mouseController.mouseDown = false;
    this.mouseController.activeController = null;
  }

  // Ignore mouse leave events when dragging an anchor.
  onMouseLeave(evt) { }
}
</pre>
<ul>
	<li>As a side note, this is getting annoying to have to implement and is 
	indicative of a potential design flaw.&nbsp; </li>
</ul>
<p>The real fun part is how the anchor controller, anchor shape, and drag event 
handlers are set up when the anchors are drawn.&nbsp; This is a change to the 
first rendition described earlier of the <code>showAnchors</code> function:</p>
<pre>showAnchors(anchors) {
  // not showing?
  if (this.anchors.length == 0) {
    var anchorGroup = getElement(ANCHORS_ID);
    // Reset any translation because the next mouse hover will set the anchors directly over the shape.
    anchorGroup.setAttributeNS(null, &quot;transform&quot;, &quot;translate(0, 0)&quot;);
    // We pass in the shape (which is also the surface) mouse controller so we can
    // handle when the shape or surface gets the mousemove event, which happens if
    // the user moves the mouse too quickly and the pointer leaves the anchor rectangle.
    this.anchorController = new AnchorController(this);

    anchors.map(anchorDefinition =&gt; {
      var anchor = anchorDefinition.anchor;
      // Note the additional translation attributes tx and ty which we use for convenience (so we don't have to parse the transform) when translating the anchor.
      var el = this.createElement(&quot;rect&quot;, { 
          x: anchor.X - 5, y: anchor.Y - 5, tx: 0, ty: 0, width: 10, height: 10, 
          fill: &quot;#FFFFFF&quot;, stroke: &quot;#808080&quot;, &quot;stroke-width&quot;: 0.5 });
      // Create anchor shape, wire up anchor events, and attach it to the MouseController::AnchorController object.
      new Anchor(this.anchorController, el, this.partialCall(el, anchorDefinition.onDrag));
      anchorGroup.appendChild(el);
    });
  }
}
</pre>
<p>Notice the additional <code>tx</code> and <code>ty</code> attributes which are used to keep track of 
the anchor translation.&nbsp; The <code>partialCall</code> function lets us pass in the 
anchor element as part of the <code>onDrag</code> callback:</p>
<pre>// We need to set up a partial call so that we can include the anchor being dragged when we call
// the drag method for moving the shape's anchor. At that point we also pass in the event data.
partialCall(anchorElement, onDrag) {
  return (function (anchorElement, onDrag) {
    return function (evt) { onDrag(anchorElement, evt); }
  })(anchorElement, onDrag);
}</pre>
<p><img border="0" src="line5.png" width="196" height="162"></p>
<h2><a name="AnchorDragOperationsforOtherShapes42">Anchor Drag Operations for Other Shapes</a></h2>
<p>Circles and other shapes that need to maintain their aspect ratio are 
annoying because all the anchor points have to move!&nbsp; We have this issue 
with other shapes as well (such as resizing a rectangle or diamond), as sizing a 
shape changes other anchor locations.&nbsp; So another refactoring (not shown) 
passes in the entire anchors collection so shapes can translate the other 
anchors when one particular anchor is being dragged.&nbsp; We wouldn't have this 
problem if we removed all anchors but the anchor being moved, which is another 
possibility, but I don't like to rely on a UI behavior to control the internal 
logic of how objects are manipulated.&nbsp; So another refactoring to how 
anchors are created:</p>
<pre>// We need to set up a partial call so that we can include the anchor being dragged when we call
// the drag method for moving the shape's anchor. At that point we also pass in the event data.
partialCall(anchors, anchorElement, onDrag) {
  return (function (anchors, anchorElement, onDrag) {
    return function (evt) { onDrag(anchors, anchorElement, evt); }
  })(anchors, anchorElement, onDrag);
}

showAnchors(anchors) {
  // not showing?
  if (this.anchors.length == 0) {
    var anchorGroup = getElement(ANCHORS_ID);
    // Reset any translation because the next mouse hover will set the anchors directly over the shape.
    anchorGroup.setAttributeNS(null, &quot;transform&quot;, &quot;translate(0, 0)&quot;);
    // We pass in the shape (which is also the surface) mouse controller so we can
    // handle when the shape or surface gets the mousemove event, which happens if
    // the user moves the mouse too quickly and the pointer leaves the anchor rectangle.
    this.anchorController = new AnchorController(this);
    var anchorElements = [];

    anchors.map(anchorDefinition =&gt; {
      var anchor = anchorDefinition.anchor;
      // Note the additional translation attributes tx and ty which we use for convenience 
      // (so we don't have to parse the transform) when translating the anchor.
      var el = this.createElement(&quot;rect&quot;, 
          { x: anchor.X - 5, y: anchor.Y - 5, tx: 0, ty: 0, width: 10, height: 10, 
            fill: &quot;#FFFFFF&quot;, stroke: &quot;#808080&quot;, &quot;stroke-width&quot;: 0.5 });
      anchorElements.push(el);
      anchorGroup.appendChild(el);
    });

    // Separate iterator so we can pass in all the anchor elements to the onDrag callback once they've been accumulated.
    for (var i = 0; i &lt; anchors.length; i++) {
      var anchorDefinition = anchors[i];
      var el = anchorElements[i];
      // Create anchor shape, wire up anchor events, and attach it to the MouseController::AnchorController object.
      new Anchor(this.anchorController, el, this.partialCall(anchorElements, el, anchorDefinition.onDrag));
    }
  }
}</pre>
<h3><a name="Circles43">Circles</a></h3>
<p><img border="0" src="circles1.png" width="230" height="202"></p>
<p>The circle anchor points are the top, bottom, middle and right:</p>
<pre>getAnchors() {
  var corners = this.getCorners();
  var middleTop = new Point((corners[0].X + corners[1].X) / 2, corners[0].Y);
  var middleBottom = new Point((corners[0].X + corners[1].X) / 2, corners[1].Y);
  var middleLeft = new Point(corners[0].X, (corners[0].Y + corners[1].Y) / 2);
  var middleRight = new Point(corners[1].X, (corners[0].Y + corners[1].Y) / 2);

  var anchors = [
    { anchor: middleTop, onDrag: this.topMove.bind(this) },
    { anchor: middleBottom, onDrag: this.bottomMove.bind(this) },
    { anchor: middleLeft, onDrag: this.leftMove.bind(this) },
    { anchor: middleRight, onDrag: this.rightMove.bind(this) }
  ];

  return anchors;
}</pre>
<p>The adjustments to the circle radius and anchor points:</p>
<pre>topMove(anchors, anchor, evt) {
  this.changeRadius(-evt.movementY);
  this.moveAnchor(anchors[0], 0, evt.movementY);
  this.moveAnchor(anchors[1], 0, -evt.movementY);
  this.moveAnchor(anchors[2], evt.movementY, 0);
  this.moveAnchor(anchors[3], -evt.movementY, 0);
}

bottomMove(anchors, anchor, evt) {
  this.changeRadius(evt.movementY);
  this.moveAnchor(anchors[0], 0, -evt.movementY);
  this.moveAnchor(anchors[1], 0, evt.movementY);
  this.moveAnchor(anchors[2], -evt.movementY, 0);
  this.moveAnchor(anchors[3], evt.movementY, 0);
}

leftMove(anchors, anchor, evt) {
  this.changeRadius(-evt.movementX);
  this.moveAnchor(anchors[0], 0, evt.movementX);
  this.moveAnchor(anchors[1], 0, -evt.movementX);
  this.moveAnchor(anchors[2], evt.movementX, 0);
  this.moveAnchor(anchors[3], -evt.movementX, 0);
}

rightMove(anchors, anchor, evt) {
  this.changeRadius(evt.movementX);
  this.moveAnchor(anchors[0], 0, -evt.movementX);
  this.moveAnchor(anchors[1], 0, evt.movementX);
  this.moveAnchor(anchors[2], -evt.movementX, 0);
  this.moveAnchor(anchors[3], evt.movementX, 0);
}

changeRadius(amt) {
  var r = +this.svgElement.getAttribute(&quot;r&quot;) + amt;
  this.svgElement.setAttribute(&quot;r&quot;, r)
}</pre>
<h3><a name="Diamonds44">Diamonds</a></h3>
<p><img border="0" src="diamonds1.png" width="237" height="214"></p>
<p>Diamonds are resized symmetrically top-bottom and left-right.&nbsp; This 
means that only the positions of the top-bottom or left-right anchors need to be 
updated when resizing vertically or horizontally, respectively.&nbsp; The most annoying problem is recalculating the path (for example: <code>d: &quot;M 240 100 
L 210 130 L 240 160 L 270 130 Z&quot;</code>) as this isn't just setting (x, y) coordinates.&nbsp; 
Given that the bounding rectangle is the absolute coordinates on the SVG 
surface, we have to remove any translations (shape and surface) when setting the 
new path values:</p>
<pre>updatePath(ulCorner, lrCorner) {
  // example path: d: &quot;M 240 100 L 210 130 L 240 160 L 270 130 Z&quot;
  this.getRelativeLocation(ulCorner);
  this.getRelativeLocation(lrCorner);
  var mx = (ulCorner.X + lrCorner.X) / 2;
  var my = (ulCorner.Y + lrCorner.Y) / 2;
  var path = &quot;M &quot; + mx + &quot; &quot; + ulCorner.Y;
  path = path + &quot; L &quot; + ulCorner.X + &quot; &quot; + my;
  path = path + &quot; L &quot; + mx + &quot; &quot; + lrCorner.Y;
  path = path + &quot; L &quot; + lrCorner.X + &quot; &quot; + my;
  path = path + &quot; Z&quot;
  this.svgElement.setAttribute(&quot;d&quot;, path);
}</pre>
<p>and in the <code>SvgElement</code> class:</p>
<pre>getRelativeLocation(p) {
  p.translate(-this.X, -this.Y);
  p.translate(-this.mouseController.surface.X, -this.mouseController.surface.Y);

  return p;
}
</pre>
<p>On a &quot;move anchor&quot; event, here's two of the four functions (the other two are 
identical except the signs are reversed):</p>
<pre>topMove(anchors, anchor, evt) {
  var ulCorner = this.getULCorner();
  var lrCorner = this.getLRCorner();
  this.changeHeight(ulCorner, lrCorner, -evt.movementY);
  this.moveAnchor(anchors[0], 0, evt.movementY); // top
  this.moveAnchor(anchors[1], 0, -evt.movementY); // bottom
}

leftMove(anchors, anchor, evt) {
  var ulCorner = this.getULCorner();
  var lrCorner = this.getLRCorner();
  this.changeWidth(ulCorner, lrCorner, -evt.movementX);
  this.moveAnchor(anchors[2], evt.movementX, 0);
  this.moveAnchor(anchors[3], -evt.movementX, 0);
}</pre>
<h3><a name="Rectangles45">Rectangles</a></h3>
<p><img border="0" src="rectangles1.png" width="274" height="223"></p>
<p>&nbsp;</p>
<p>For simplicity, we'll just use create the four anchors we've been using for 
circles and diamonds.&nbsp; Unlike diamonds, moving an anchor is <i>not</i> 
symmetrical, so in addition to the anchor itself, the diagonal anchors have to 
be updated as well.&nbsp; The only nuance here is in manipulating the (x, width) 
and (y, height) values.&nbsp; Again, illustrating only the code for top and left 
anchor moves (right and bottom sign changes and only adjust width and height):</p>
<pre>topMove(anchors, anchor, evt) {
  // Moving the top affects &quot;y&quot; and &quot;height&quot;
  var y = +this.svgElement.getAttribute(&quot;y&quot;) + evt.movementY;
  var height = +this.svgElement.getAttribute(&quot;height&quot;) - evt.movementY;
  this.svgElement.setAttribute(&quot;y&quot;, y);
  this.svgElement.setAttribute(&quot;height&quot;, height);
  this.moveAnchor(anchors[0], 0, evt.movementY);
  this.adjustAnchorY(anchors[2], evt.movementY/2);
  this.adjustAnchorY(anchors[3], evt.movementY / 2);
}

leftMove(anchors, anchor, evt) {
  // Moving the left affects &quot;x&quot; and &quot;width&quot;
  var x = +this.svgElement.getAttribute(&quot;x&quot;) + evt.movementX;
  var width = +this.svgElement.getAttribute(&quot;width&quot;) - evt.movementX;
  this.svgElement.setAttribute(&quot;x&quot;, x);
  this.svgElement.setAttribute(&quot;width&quot;, width);
  this.moveAnchor(anchors[2], evt.movementX, 0);
  this.adjustAnchorX(anchors[0], evt.movementX / 2);
  this.adjustAnchorX(anchors[1], evt.movementX / 2);
}</pre>
<p>And there are a couple new helper functions in the SvgElement class:</p>
<pre>adjustAnchorX(anchor, dx) {
  var tx = +anchor.getAttribute(&quot;tx&quot;) + dx;
  var ty = +anchor.getAttribute(&quot;ty&quot;);
  anchor.setAttribute(&quot;transform&quot;, &quot;translate(&quot; + tx + &quot;,&quot; + ty + &quot;)&quot;);
  anchor.setAttribute(&quot;tx&quot;, tx);
  anchor.setAttribute(&quot;ty&quot;, ty);
}

adjustAnchorY(anchor, dy) {
  var tx = +anchor.getAttribute(&quot;tx&quot;);
  var ty = +anchor.getAttribute(&quot;ty&quot;) + dy;
  anchor.setAttribute(&quot;transform&quot;, &quot;translate(&quot; + tx + &quot;,&quot; + ty + &quot;)&quot;);
  anchor.setAttribute(&quot;tx&quot;, tx);
  anchor.setAttribute(&quot;ty&quot;, ty);
}</pre>
<p>We can now resize and re-orient lines!&nbsp; One annoyance with the current 
implementation is that the anchor only appears when the mouse enters the shape.&nbsp; 
This leads to a minor but awkward mouse gesturing where the mouse has to be 
moved <i>into</i> the shape and then back <i>out</i> to the edge to select the 
anchor.&nbsp; This issue exists with connection points as well.&nbsp; One way to 
deal with this is that each shape needs to be in a group with a transparent but 
slightly larger mirror shape.&nbsp; It's on the todo list.</p>
<h2><a name="Text46">Text</a></h2>
<p><img border="0" src="text1.png" width="424" height="202"></p>
<p>One last thing in this article to make this application at least minimally 
useful - the ability to add some text to the diagram.&nbsp; At the moment, 
there's no fancy font, font size, alignment, or word wrapping features.&nbsp; 
Also, text is an independent shape -- if you overlay text on a rectangle, the 
text will not move when you move the rectangle.&nbsp; This is bare-bones 
functionality!&nbsp; </p>
<p>Adding the toolbox 
text shape to the toolbox group:</p>
<pre>&lt;text id=&quot;toolboxText&quot; x=&quot;73&quot; y=&quot;100&quot; font-size=&quot;32&quot; font-family=&quot;Verdana&quot;&gt;A&lt;/text&gt;</pre>
<p>There is also a supporting <code>Text</code> and <code>ToolboxClass</code> with 
typical implementation with one minor variation -- setting the inner HTML:</p>
<pre>createElement() {
  var el = super.createElement('text', { x: 240, y: 100, &quot;font-size&quot;: 12, &quot;font-family&quot;: &quot;Verdana&quot; });
  el.innerHTML = &quot;[text]&quot;;

  return el;
}</pre>
<p>Same with the <code>createElementAt</code> function.</p>
<p>I also don't want the cursor to change to an I-beam when the mouse moves 
over a text element, so our first (and only) CSS:</p>
<pre>&lt;style&gt;
  text {cursor:default}
&lt;/style&gt;</pre>
<h3><a name="ChangingText47">Changing Text</a></h3>
<p>As I mentioned earlier, I'm less interested in a fancy UI at the moment and 
more interested in getting the basic behaviors ironed out.&nbsp; So to set the 
text, one selects the shape and then enters the text in the edit box at the top 
of the diagram as shown in the screenshot at the start of this section.&nbsp; 
The implementation, in the Text class, is trivial:</p>
<pre>class Text extends SvgElement {
  constructor(mouseController, svgElement) {
    super(mouseController, svgElement);
    this.registerEventListener(svgElement, &quot;mousedown&quot;, this.onMouseDown);
  }

  // Update the UI with the text associated with the shape.
  onMouseDown(evt) {
    var text = this.svgElement.innerHTML;
    document.getElementById(&quot;text&quot;).value = text;
  }

  setText(text) {
    this.svgElement.innerHTML = text;
  }
}</pre>
<p>The only interesting thing to note here is that the <code>Text</code> class adds a second 
<code>mousedown</code> event handler so that it can set the text of text shape into the input 
box on the screen.&nbsp; When the text is changed in the input box, the selected 
shape's <code>setText</code> method is called:</p>
<pre>// Update the selected shape's text. Works only with text shapes right now.
function setText() {
  if (mouseController.selectedShape != null) {
    var text = document.getElementById(&quot;text&quot;).value;
    mouseController.selectedShape.setText(text);
  }
}</pre>
<p>It's a bit kludgy, using the global <code>mouseController</code> and so forth, but we can expand upon this later to have 
all shapes include a text area.</p>
<h2><a name="RefactoringthePrototypetouseanMVCPattern48">Refactoring the Prototype to use an MVC Pattern</a></h2>
<p>So far we've avoided having to maintain and persist a separate model.&nbsp; 
The shape classes <code>Rectangle</code>, <code>Text</code>, <code>Circle</code>, and so forth are more controllers 
than models, though there is a bit of entanglement evident in the 
<code>createShapeControllers</code> function, which is called when loading a diagram.&nbsp; 
This fragment:</p>
<pre>shape.X = +translate[0];
shape.Y = +translate[1];</pre>
<p>is clue that we're entangling controller and model.&nbsp; Similarly, in the 
<code>Surface</code> class, the <code>serialize</code> / <code>deserialize</code> functions are another clue that 
controller and model are being entangled.&nbsp; The code for serializing the 
surface data is itself rather hacky.&nbsp; Reviewing it:</p>
<pre>serialize() {
  var el = document.createElement(&quot;surface&quot;);
  // DOM adds elements as lowercase, so let's just start with lowercase keys.
  var attributes = {x : this.X, y : this.Y, gridcellw : this.gridCellW, gridcellh : this.gridCellH, cellw : this.cellW, cellh : this.cellH}
  Object.entries(attributes).map(([key, val]) =&gt; el.setAttribute(key, val));
  var serializer = new XMLSerializer();
  var xml = serializer.serializeToString(el);

  return xml;
}</pre>
<p>Besides the kludge of dealing with lowercase attributes, we also have the 
hack of serializing to XML to stay consistent with the actual SVG object graph 
serialization, which is also in XML.&nbsp; There are some options that should be 
considered.</p>
<ul>
	<li>Serialize only the model and reconstruct the SVG object graph from the 
	model.&nbsp; The drawback here is that the SVG, serialized as XML, is easily 
	imported into some other application.&nbsp; Of course, we could add an 
	&quot;export&quot; function if we want this behavior.</li>
	<li>Serialize the SVG object graph as XML and the shape models as JSON, 
	which is more Javascript native.&nbsp; We either entangle XML and JSON in 
	the same file or save them as separate files.</li>
</ul>
<p>At the end of the day, I think the preferred approach is the serialize the <i>
model</i> and reconstruct the SVG object graph <i>from the model</i>.</p>
<h3><a name="Models,Views,andControllers49">Models, Views, and Controllers</a></h3>
<p>Here's the basic MVC pattern:</p>
<p><img border="0" src="mvc1.png" width="524" height="409"></p>
<p>Each shape implements its own specific model, view, and controller.&nbsp; For 
example (because it's interesting) here are the MVC classes for the text shape:</p>
<h3><a name="TheTextModel50">The Text Model</a></h3>
<pre>class TextModel extends ShapeModel {
  constructor() {
    super();
    this._x = 0;
    this._y = 0;
    this._text = &quot;&quot;;
  }

  get x() { return this._x; }
  get y() { return this._y; }
  get text() { return this._text; }

  set x(value) {
    this._x = value;
    this.propertyChanged(&quot;x&quot;, value);
  }

  set y(value) {
    this._y = value;
    this.propertyChanged(&quot;y&quot;, value);
  }

  set text(value) {
    this._text = value;
    this.propertyChanged(&quot;text&quot;, value);
  }
}</pre>
<h3><a name="TheTextController51">The Text Controller</a></h3>
<pre>class TextController extends Controller {
  constructor(mouseController, view, model) {
    super(mouseController, view, model);
  }

  // Update the UI with the text associated with the shape.
  onMouseDown(evt) {
    super.onMouseDown(evt);
    var text = this.model.text;
    document.getElementById(&quot;text&quot;).value = text;
    this.mouseController.selectedShapeController = this;
  }
}</pre>
<h3><a name="TheTextView52">The Text View</a></h3>
<pre>class TextView extends View{
  constructor(svgElement, model) {
    super(svgElement, model);
  }

  // Custom handling for property &quot;text&quot;
  onPropertyChange(property, value) {
    if (property == &quot;text&quot;) {
      this.svgElement.innerHTML = value;
    } else {
      super.onPropertyChange(property, value);
    }
  }
}</pre>
<h3><a name="TheBaseModel53">The Base Model</a></h3>
<p>Every shape requires translation, so the base <code>Model</code> class handles these 
properties and provides some helper methods:</p>
<pre>class Model {
  constructor() {
    this.eventPropertyChanged = null;

    this._tx = 0;
    this._ty = 0;
  }

  get tx() { return this._tx; }
  get ty() { return this._ty; }

  propertyChanged(propertyName, value) {
    if (this.eventPropertyChanged != null) {
      this.eventPropertyChanged(propertyName, value);
    }
  }

  translate(x, y) {
    this._tx += x;
    this._ty += y;
    this.setTranslate(this._tx, this._ty);
  }

  // Update our internal translation and set the translation immediately.
  setTranslation(x, y) {
    this._tx = x;
    this._ty = y;
    this.setTranslate(x, y);
  }

  // Deferred translation -- this only updates _tx and _ty
  // Used when we want to internally maintain the true _tx and _ty
  // but set the translation to a modulus, as in when translating
  // the grid.
  updateTranslation(dx, dy) {
    this._tx += dx;
    this._ty += dy;
  }

  // Sets the &quot;translate&quot; portion of the &quot;transform&quot; property.
  // All models have a translation. Notice we do not use _tx, _ty here
  // nor do we set _tx, _ty to (x, y) because (x, y) might be mod'ed by
  // the grid (w, h). We want to use exactly the parameters passed in
  // without modifying our model.
  // See SurfaceController.onDrag and note how the translation is updated
  // but setTranslate is called with the mod'ed (x, y) coordinates.
  setTranslate(x, y) {
    this.translation = &quot;translate(&quot; + x + &quot;,&quot; + y + &quot;)&quot;;
    this.transform = this.translation;
  }

  // TODO: Later to be extended to build the transform so that it includes rotation and other things we can do.
  set transform(value) {
    this._transform = value;
    this.propertyChanged(&quot;transform&quot;, value);
  }

  set tx(value) {
    this._tx = value;
    this.translation = &quot;translate(&quot; + this._tx + &quot;,&quot; + this._ty + &quot;)&quot;;
    this.transform = this.translation;
  }

  set ty(value) {
    this._ty = value;
  this.translation = &quot;translate(&quot; + this._tx + &quot;,&quot; + this._ty + &quot;)&quot;;
  this.transform = this.translation;
  }
}</pre>
<h3><a name="TheBaseView54">The Base View</a></h3>
<p>The base <code>View</code> class has a helper function for acquiring the ID of the SVG 
element and sets the attribute of the associated SVG element:</p>
<pre>class View {
  constructor(svgElement, model) {
    this.svgElement = svgElement;
    model.eventPropertyChanged = this.onPropertyChange.bind(this);
  }

  get id() {
    return this.svgElement.getAttribute(&quot;id&quot;);
  }

  onPropertyChange(property, value) {
    this.svgElement.setAttribute(property, value);
  }
}</pre>
<p>Also notice that the constructor wires up the property changed &quot;event&quot; that 
the model fires.</p>
<h3><a name="CreatingaShapeProgrammatically55">Creating a Shape Programmatically</a></h3>
<p>Given the new MVC architecture, here's how a shape is created 
programmatically.&nbsp; Notice that the model must be initialized to match the 
shape attribute values.&nbsp; Also notice that right now, our model doesn't 
handle other attributes such as fill, stroke, and stroke-width.&nbsp; We don't 
have UI support for that yet, so I haven't implemented those properties of the 
model.</p>
<pre>var rectEl = Helpers.createElement('rect', { x: 240, y: 100, width: 60, height: 60, fill: &quot;#FFFFFF&quot;, stroke: &quot;black&quot;, &quot;stroke-width&quot;: 1 });
var rectModel = new RectangleModel();
rectModel._x = 240;
rectModel._y = 100;
rectModel._width = 60;
rectModel._height = 60;
var rectView = new ShapeView(rectEl, rectModel);
var rectController = new RectangleController(mouseController, rectView, rectModel);
Helpers.getElement(Constants.SVG_OBJECTS_ID).appendChild(rectEl);
mouseController.attach(rectView, rectController);
// Most shapes also need an anchor controller
mouseController.attach(rectView, anchorGroupController);</pre>
<p>Also notice how the mouse controller now supports multiple shape controllers!</p>
<h3><a name="Serialization56">Serialization</a></h3>
<p>It's probably worth taking a quick look at how serialization works now:</p>
<pre>// Returns JSON of serialized models.
serialize() {
  var uberModel = [];
  var model = surfaceModel.serialize();
  model[Object.keys(model)[0]].id = Constants.SVG_SURFACE_ID;
  uberModel.push(model);

  this.models.map(m =&gt; {
    var model = m.model.serialize();
    model[Object.keys(model)[0]].id = m.id;
    uberModel.push(model);
  });

  return JSON.stringify(uberModel);
}</pre>
<p>The concrete model is responsible for serializing itself.&nbsp; The 
serializer tacks on the shape's ID which is actually not part of the model, it's 
part of the view!&nbsp; This code looks a bit weird because when a shape is 
dropped on to the surface, only the model and the shape's ID is registered in 
the diagram controller like this:</p>
<pre>addModel(model, id) {
  this.models.push({ model: model, id: id });
}</pre>
<p>Hence this abomination of code: <code>model[Object.keys(model)[0]].id = m.id;</code>
&nbsp;</p>
<p>The model dictionary has only one entry, the key is the shape name, and the 
value is the collection of attributes, to which we're adding &quot;id&quot;.&nbsp; For 
example, a blank surface serializes like this:</p>
<pre>[{&quot;Surface&quot;:{&quot;tx&quot;:0,&quot;ty&quot;:0,&quot;gridCellW&quot;:100,&quot;gridCellH&quot;:100,&quot;cellW&quot;:20,&quot;cellH&quot;:20,&quot;id&quot;:&quot;surface&quot;}}]</pre>
<h3><a name="Deserializing57">Deserializing</a></h3>
<p>Restoring the diagram is a bit more complicated because the appropriate 
model, view, and controller classes must be created as well as the SVG element.&nbsp; 
Deserializing the actual SVG element attributes is again left to the concrete 
model.</p>
<pre>// Creates an MVC for each model of the provided JSON.
deserialize(jsonString) {
  var models = JSON.parse(jsonString);
  var objectModels = [];
  surfaceModel.setTranslation(0, 0);
  objectsModel.setTranslation(0, 0);

  models.map(model =&gt; {
    var key = Object.keys(model)[0];
      var val = model[key];

      if (key == &quot;Surface&quot;) {
      // Special handler for surface, we keep the existing MVC objects.
      // We set both the surface and objects translation, but the surface translation
      // is mod'd by the gridCellW/H.
      surfaceModel.deserialize(val);
      objectsModel.setTranslation(surfaceModel.tx, surfaceModel.ty);
    } else {
      var model = new this.mvc[key].model();
      objectModels.push(model);
      var el = this.mvc[key].creator();
      // Create the view first so it hooks into the model's property change event.
      var view = new this.mvc[key].view(el, model);
      model.deserialize(val, el);
      view.id = val.id;
      var controller = new this.mvc[key].controller(mouseController, view, model);

      // Update our diagram's model collection.
      this.models.push({ model: model, id: val.id });

      Helpers.getElement(Constants.SVG_OBJECTS_ID).appendChild(el);
      this.mouseController.attach(view, controller);

      // Most shapes also need an anchor controller. An exception is the Text shape, at least for now.
      if (controller.shouldShowAnchors) {
        this.mouseController.attach(view, anchorGroupController);
      }
    }
  });
}</pre>
<p>The whole process is driven by a table that determines what actual MVC 
classes to instantiate, as well as any custom SVG element instantiation 
requirements:</p>
<pre>this.mvc = {
  Rectangle: { model: RectangleModel, view: ShapeView, controller: RectangleController, creator : () =&gt; this.createElement(&quot;rect&quot;) },
  Circle: { model: CircleModel, view: ShapeView, controller: CircleController, creator: () =&gt; this.createElement(&quot;circle&quot;) },
  Diamond: { model: DiamondModel, view: ShapeView, controller: DiamondController, creator: () =&gt; this.createElement(&quot;path&quot;) },
  Line: { model: LineModel, view: LineView, controller: LineController, creator: () =&gt; this.createLineElement() },
  Text: { model: TextModel, view: TextView, controller: TextController, creator: () =&gt; this.createTextElement() },
};</pre>
<h2><a name="ConnectingLines58">Connecting Lines</a></h2>
<p><img border="0" src="cp1.png" width="182" height="192"></p>
<p>Now that we have a solid MVC architecture, the additional glue required to 
manage connected lines (lines endpoints connected to shapes) can be 
accomplished.&nbsp; This involves:</p>
<ul>
	<li>Connection points on the shape.</li>
	<li>Showing those connection points.</li>
	<li>Managing what line endpoint is connected to what shape's connection 
	point.<ul>
		<li>Attaching endpoints</li>
		<li>Detaching endpoints</li>
		<li>Persisting connections</li>
	</ul>
	</li>
	<li>Moving the lines when the shape moves.</li>
	<li>Moving the lines when the shape size changes.</li>
</ul>
<p>That's a lot!&nbsp; Hopefully we can be efficient about how we implement all 
this.</p>
<h3><a name="ConnectionPoints59">Connection Points</a></h3>
<p>For the moment, I'm going to keep connection points simple, meaning that for 
circles and diamonds, there's no 45 / 135 / 225 / 315 degree points (or even 
others.)&nbsp; For rectangles, there's no intermediate connection points between 
the edge and the midpoint.&nbsp; Connection points, like anchors, will for now 
be the cardinal compass points: N, S, E, W.&nbsp; However, we'll implement the 
structure so that it can be extended later on.&nbsp; As such, defining 
connection points looks very similar to defining anchors, except that there's no 
behavior associated with a connection point, it's just a visual aid.&nbsp; In 
the full blown implementation, connection points can be added, removed, moved 
around, and so forth, so what <i>is </i>important is that we have some way to 
associate a name (even if it's an auto-generated GUID) to a connection point so 
there is something concrete to use as a reference between the line endpoint and 
the shape connection point rather than just an index into an array.</p>
<p>As with anchors, we have a function that returns the connection points 
available to the shape.&nbsp; Custom connection points are currently not 
supported.&nbsp; I also compromise on the implementation in that instead of 
giving a connection point an actual ID, I'm &quot;remembering&quot; connection points by 
their index in the list of connection points.&nbsp; This is not idea for the 
future where the user should be able to add/remove connection points on the 
shape.&nbsp; That said, here's how the connection points for the rectangle shape 
are defined (it will look very similar to anchors):</p>
<pre>getConnectionPoints() {
  var corners = this.getCorners();
  var middleTop = new Point((corners[0].x + corners[1].x) / 2, corners[0].y);
  var middleBottom = new Point((corners[0].x + corners[1].x) / 2, corners[1].y);
  var middleLeft = new Point(corners[0].x, (corners[0].y + corners[1].y) / 2);
  var middleRight = new Point(corners[1].x, (corners[0].y + corners[1].y) / 2);

  var connectionPoints = [
    { connectionPoint: middleTop },
    { connectionPoint: middleBottom },
    { connectionPoint: middleLeft },
    { connectionPoint: middleRight }
  ];

  return connectionPoints;
}</pre>
<p>The <code>connectionPoints</code> array is a dictionary of just one key-value pair -- this 
is overkill at the moment, but I suspect that like with anchors, some additional 
data will at some point be necessary.</p>
<h3><a name="DetectingShapesThatWe'reNear60">Detecting Shapes That We're Near</a></h3>
<p><img border="0" src="cp2.png" width="178" height="179"></p>
<p>The logical place to put the code that controls connecting / disconnecting 
from shapes is the <code>AnchorController</code>, which is created for each anchor when the 
mouse hovers over a shape.&nbsp; Also, only certain shapes (like lines) can 
connect to other shapes.&nbsp; So in the <code>AnchorController</code>, the <code>onDrag</code> function 
gets to also handle showing connection points of nearyby shapes:</p>
<pre>onDrag(dx, dy) {
  // Call into the shape controller to handle
  // the specific anchor drag.
  this.fncDragAnchor(dx, dy);
  this.showAnyConnectionPoints();
}
</pre>
<p>Where the function <code>showAnyConnectionPoints</code> manages both the list of shapes currently displaying connection 
points as well as calling functions to show or remove the connection points of 
nearby shapes:</p>
<pre>showAnyConnectionPoints() {
  if (this.shapeController.canConnectToShapes) {
    var changes = this.getNewNearbyShapes(this.mouseController.x, this.mouseController.y);
    this.createConnectionPoints(changes.newShapes);

    // Other interesting approaches:
    // https://stackoverflow.com/questions/1885557/simplest-code-for-array-intersection-in-javascript
    // [...new Set(a)].filter(x =&gt; new Set(b).has(x));
    var currentShapesId = changes.newShapes.concat(changes.existingShapes).map(ns =&gt; ns.id);

    var noLongerNearShapes = this.shapeConnectionPoints.filter(s =&gt; currentShapesId.indexOf(s.id) &lt; 0);
    this.removeExpiredShapeConnectionPoints(noLongerNearShapes);

    // Remove any shapes from the shapeConnectionPoints that do not exist anymore.
    var existingShapesId = changes.existingShapes.map(ns =&gt; ns.id);
    this.shapeConnectionPoints = this.shapeConnectionPoints.filter(s =&gt; existingShapesId.indexOf(s.id) &gt;= 0);

    // Add in the new shapes.
    this.shapeConnectionPoints = this.shapeConnectionPoints.concat(changes.newShapes);

    console.log(&quot;scp: &quot; + this.shapeConnectionPoints.length + &quot;, new: &quot; + changes.newShapes.length + &quot;, existing: &quot; + existingShapesId.length);
  }
}
</pre>
<p>This is really just a bunch of map and filter calls to add new shapes to the 
current shape connection points and remove old shapes that no longer should be 
showing connection points.</p>
<p>With <code>getNewNearbyShapes</code>, it's useful to return both new shapes to which we're near 
and any existing shapes to which we're still near:</p>
<pre>getNewNearbyShapes(x, y) {
  var newShapes = [];
  var existingShapes = [];
  var p = new Point(x, y);
  p = Helpers.translateToScreenCoordinate(p);
  var nearbyShapeEls = Helpers.getNearbyShapes(p);

  // logging:
  // nearbyShapesEls.map(s =&gt; console.log(s.outerHTML.split(&quot; &quot;)[0].substring(1)));

  nearbyShapeEls.map(el =&gt; {
    var controllers = this.mouseController.getControllersByElement(el);
</pre>
<pre>    if (controllers) {
      controllers.map(ctrl =&gt; {
        if (ctrl.hasConnectionPoints) {
          var shapeId = ctrl.view.id;

          // If it already exists in the list, don't add it again.
          if (!this.shapeConnectionPoints.any(cp =&gt; cp.id == shapeId)) {
            var connectionPoints = ctrl.getConnectionPoints();
            newShapes.push({ id: shapeId, controller: ctrl, connectionPoints: connectionPoints });
          } else {
            existingShapes.push({ id: shapeId });
          }
        }
      });
    }
  });

  return { newShapes : newShapes, existingShapes: existingShapes };
}</pre>
<p>The salient part of this is that new shapes consist of the structure <code>{shape 
ID, controller, connection points}</code> and existing shapes is just the structure 
<code>{shape ID}</code>.&nbsp; In the previous function, these two lists are 
concatenated an the common shape ID is mapped into the collection of shapes 
currently showing connection points:</p>
<pre>var currentShapesId = changes.newShapes.concat(changes.existingShapes).map(ns =&gt; ns.id);</pre>
<h3><a name="ShowingConnectionPoints61">Showing Connection Points</a></h3>
<pre>// &quot;shapes&quot; is a {id, controller, connectionPoints} structure
createConnectionPoints(shapes) {
  var cpGroup = Helpers.getElement(Constants.SVG_CONNECTION_POINTS_ID);

  shapes.map(shape =&gt; {
    shape.connectionPoints.map(cpStruct =&gt; {
      var cp = cpStruct.connectionPoint;
      var el = Helpers.createElement(&quot;g&quot;, { connectingToShapeId: shape.id });
      el.appendChild(Helpers.createElement(&quot;line&quot;, 
        { x1: cp.x - 5, y1: cp.y - 5, x2: cp.x + 5, y2: cp.y + 5, fill: &quot;#FFFFFF&quot;, stroke: &quot;#000080&quot;, &quot;stroke-width&quot;: 1 }));
      el.appendChild(Helpers.createElement(&quot;line&quot;, 
        { x1: cp.x + 5, y1: cp.y - 5, x2: cp.x - 5, y2: cp.y + 5, fill: &quot;#FFFFFF&quot;, stroke: &quot;#000080&quot;, &quot;stroke-width&quot;: 1 }));
      cpGroup.appendChild(el);
    });
  });
}</pre>
<p>Any shapes for which we want to show connection points adds a group with two 
lines that form an X to the connection points group.&nbsp; Notice the attribute 
<code>connectingToShapeId</code> that sets the shape ID for the associated shape.&nbsp; 
We use this information next to remove connection points for a particular shape.</p>
<h3><a name="RemovingConnectionPoints62">Removing Connection Points</a></h3>
<pre>// &quot;shapes&quot; is a {id, controller, connectionPoints} structure
removeExpiredShapeConnectionPoints(shapes) {
  shapes.map(shape =&gt; {
    // <a href="https://stackoverflow.com/a/16775485/2276361">https://stackoverflow.com/a/16775485/2276361</a>
    var nodes = document.querySelectorAll('[connectingtoshapeid=&quot;' + shape.id + '&quot;]');
    // or: Array.from(nodes); <a href="https://stackoverflow.com/a/36249012/2276361">https://stackoverflow.com/a/36249012/2276361</a>
    // <a href="https://stackoverflow.com/a/33822526/2276361">https://stackoverflow.com/a/33822526/2276361</a>
    [...nodes].map(node =&gt; { node.parentNode.removeChild(node) });
  });
}</pre>
<p>Removing connection points involves a document query to get all the 
connection point SVG groups associated with the shape and removing the child 
node.</p>
<h3><a name="ConnectingtoaShape63">Connecting to a Shape</a></h3>
<p>Connecting to a shape involves finding the connection point (assuming we find 
only one) that the mouse is closest too and snapping the anchor point of the 
line to the connection point of the shape.&nbsp; We also tell the diagram model 
about the new connection.&nbsp; Here we see how the connection point index is 
used to track the actual connection point on the shape.</p>
<pre>connectIfCloseToShapeConnectionPoint() {
  var p = new Point(this.mouseController.x, this.mouseController.y);
  p = Helpers.translateToScreenCoordinate(p);

  var nearbyConnectionPoints = [];

  this.shapeConnectionPoints.filter(scp =&gt; {
    for (var i = 0; i &lt; scp.connectionPoints.length; i++) {
      var cpStruct = scp.connectionPoints[i];
      if (Helpers.isNear(cpStruct.connectionPoint, p, Constants.MAX_CP_NEAR)) {
        nearbyConnectionPoints.push({ shapeController: scp.controller, shapeCPIdx : i, connectionPoint : cpStruct.connectionPoint});
      }
    }
  });

  if (nearbyConnectionPoints.length == 1) {
    var ncp = nearbyConnectionPoints[0];

    // The location of the connection point of the shape to which we're connecting.
    var p = ncp.connectionPoint;
    // Physical location of endpoint is without line and surface translations.
    p = p.translate(-this.shapeController.model.tx, -this.shapeController.model.ty);
    p = p.translate(-surfaceModel.tx, - surfaceModel.ty);
    // Move the endpoint of the shape from which we're connecting (the line) to this point.
    this.shapeController.connect(this.anchorIdx, p);
    diagramModel.connect(ncp.shapeController.view.id, this.shapeController.view.id, ncp.shapeCPIdx, this.anchorIdx);
  }
}</pre>
<p>A drawback with this approach is that it only works when dragging the 
endpoint anchor.&nbsp; If you're dragging the line, we're not detecting whether 
an endpoint is approaching another shape's connection point.</p>
<h3><a name="UpdatingConnectionswhentheShapeisMoved64">Updating Connections when the Shape is Moved</a></h3>
<p><img border="0" src="cp3.png" width="233" height="160"></p>
<p>This was a simple addition to the <code>Controller</code> class <code>onDrag</code> function:</p>
<pre> // Default behavior
onDrag(dx, dy)
{
  this.model.translate(dx, dy);
  this.adjustConnections(dx, dy);
}

// Adjust all connectors connecting to this shape.
adjustConnections(dx, dy) {
  var connections = diagramModel.connections.filter(c =&gt; c.shapeId == this.view.id);
  connections.map(c =&gt; {
    // TODO: Sort of nasty assumption here that the first controller is the line controller
    var lineController = this.mouseController.getControllersById(c.lineId)[0];
    lineController.translateEndpoint(c.lineAnchorIdx, dx, dy);
  });
}</pre>
<p>Notice how translateEndpoint relies on the anchor index -- again, not ideal 
but quite sufficient for the current implementation:</p>
<pre>translateEndpoint(idx, dx, dy) {
  switch (idx) {
    case 0:
      var p = new Point(this.model.x1, this.model.y1);
      p = p.translate(dx, dy);
      this.model.x1 = p.x;
      this.model.y1 = p.y;
      break;
    case 1:
      var p = new Point(this.model.x2, this.model.y2);
      p = p.translate(dx, dy);
      this.model.x2 = p.x;
      this.model.y2 = p.y;
      break;
  }
}</pre>
<p>Moving a line's endpoint is a simple matter of updating the endpoint based on 
the movement of the shape.</p>
<h3><a name="UpdatingConnectionswhentheShapeisResized65">Updating Connections when the Shape is Resized</a></h3>
<p><img border="0" src="cp4.png" width="240" height="154"></p>
<p>The <code>Controller</code> class implements the common function to translate line 
endpoints attached to the shape being resized:</p>
<pre>// Adjust the connectors connecting to this shape's connection point.
adjustConnectorsAttachedToConnectionPoint(dx, dy, cpIdx) {
  var connections = diagramModel.connections.filter(c =&gt; c.shapeId == this.view.id &amp;&amp; c.shapeCPIdx == cpIdx);
  connections.map(c =&gt; {
    // TODO: Sort of nasty assumption here that the first controller is the line controller
    var lineController = this.mouseController.getControllersById(c.lineId)[0];
    lineController.translateEndpoint(c.lineAnchorIdx, dx, dy);
  });
}</pre>
<p>When the anchor point (which at the moment always an associated connection 
point) is moved, the shape controller itself is responsible for calling the 
method to adjust any connections to that anchor/connection point.&nbsp; Here's 
an example of what happens when the top anchor of the rectangle shape is moved:</p>
<pre>topMove(anchors, anchor, dx, dy) {
  // Moving the top affects &quot;y&quot; and &quot;height&quot;
  var y = this.model.y + dy;
  var height = this.model.height - dy;
  this.model.y = y;
  this.model.height = height;
  this.moveAnchor(anchors[0], 0, dy);
  this.adjustAnchorY(anchors[2], dy / 2);
  this.adjustAnchorY(anchors[3], dy / 2);
  this.adjustConnectorsAttachedToConnectionPoint(0, dy, 0);
  this.adjustConnectorsAttachedToConnectionPoint(0, dy / 2, 2);
  this.adjustConnectorsAttachedToConnectionPoint(0, dy / 2, 3);
}</pre>
<p>Certainly the code can be improved, the use of indices is annoying, and the 
switching of anchor-dx-dy and dx-dy-anchorIndex parameter order is also 
annoying.&nbsp; But it illustrates the point that each anchor &quot;drag&quot; function is 
responsible for figuring out how connection points (which also happen to be the 
anchor coordinates and in the same order) are adjusted.</p>
<h3><a name="DisconnectingConnections66">Disconnecting Connections</a></h3>
<p>When the entire line is moved, both endpoints are disconnected from any 
potential connections:</p>
<pre>onDrag(dx, dy) {
  super.onDrag(dx, dy);
  // When the entire line is being dragged, we disconnect any connections.
  diagramModel.disconnect(this.view.id, 0);
  diagramModel.disconnect(this.view.id, 1);
}</pre>
<p>This is a simple filter operation in the diagram controller:</p>
<pre>// Disconnect any connections associated with the line and anchor index.
disconnect(lineId, lineAnchorIdx) {
  this.connections = this.connections.filter(c =&gt; !(c.lineId == lineId &amp;&amp; c.lineAnchorIdx == lineAnchorIdx));
}</pre>
<p>Similarly, whenever one of the endpoints of the line is moved, it is 
disconnected from any shape to which it might be connected.&nbsp; Note the use 
of indexing the connection point (aka the anchor index):</p>
<pre>// Move the (x1, y1) coordinate.
moveULCorner(anchors, anchor, dx, dy) {
  this.model.x1 = this.model.x1 + dx;
  this.model.y1 = this.model.y1 + dy;
  this.moveAnchor(anchor, dx, dy);
  diagramModel.disconnect(this.view.id, 0);
}

// Move the (x2, y2) coordinate.
moveLRCorner(anchors, anchor, dx, dy) {
  this.model.x2 = this.model.x2 + dx;
  this.model.y2 = this.model.y2 + dy;
  this.moveAnchor(anchor, dx, dy);
  diagramModel.disconnect(this.view.id, 1);
}</pre>
<h2><a name="RemovingAShape67">Removing A Shape</a></h2>
<p>I almost forgot this!&nbsp; Removing a shape is an involved process of:</p>
<ul>
	<li>detaching the shape from the mouse controller</li>
	<li>unwiring events</li>
	<li>removing anchors (as the shape is currently being hovered over)</li>
	<li>removing it from the model</li>
	<li>disconnecting any connections to the shape.</li>
	<li>removing it from the &quot;objects&quot; collection so it's gone from the diagram</li>
</ul>
<p>Fortunately, these are mostly one-line calls into various controllers and 
models:</p>
<pre>...
case Constants.KEY_DELETE:
  // Mouse is &quot;leaving&quot; this control, this removes any anchors.
  this.currentHoverControllers.map(c =&gt; c.onMouseLeave());

  // Remove shape from diagram model, and all connections of this shape.
  diagramModel.removeShape(this.hoverShapeId);

  // Remove shape from mouse controller and detach events.
  this.destroyShapeById(this.hoverShapeId);

  // Remove from &quot;objects&quot; collection.
  var el = Helpers.getElement(this.hoverShapeId);
  el.parentNode.removeChild(el);

  // Cleanup.
  this.currentHoverControllers = [];
  this.hoverShapeId = null;
  handled = true;
  break;
...</pre>
<h2><a name="LineArrows">Line Arrows</a></h2>
<p>
<img border="0" src="linearrows.png" width="170" height="60"></p>
<p>Line arrows are implemented using the <code>marker-start</code> and <code>marker-end</code> SVG tags:</p>
<pre>&lt;g id=&quot;toolboxLineWithStart&quot;&gt;
  &lt;rect id=&quot;lineHiddenSelectionArea&quot; x=&quot;65&quot; y=&quot;70&quot; width=&quot;40&quot; height=&quot;40&quot; stroke-opacity=&quot;0&quot; fill-opacity=&quot;0&quot; /&gt;
  &lt;line id=&quot;line&quot; x1=&quot;65&quot; y1=&quot;70&quot; x2=&quot;105&quot; y2=&quot;110&quot; fill=&quot;#FFFFFF&quot; stroke=&quot;black&quot; stroke-width=&quot;1&quot; 
        marker-start=&quot;url(#trianglestart)&quot; /&gt;
&lt;/g&gt;
  &lt;g id=&quot;toolboxLineWithStartEnd&quot;&gt;
  &lt;rect id=&quot;lineHiddenSelectionArea&quot; x=&quot;120&quot; y=&quot;70&quot; width=&quot;40&quot; height=&quot;40&quot; stroke-opacity=&quot;0&quot; fill-opacity=&quot;0&quot; /&gt;
  &lt;line id=&quot;line&quot; x1=&quot;120&quot; y1=&quot;70&quot; x2=&quot;160&quot; y2=&quot;110&quot; fill=&quot;#FFFFFF&quot; stroke=&quot;black&quot; stroke-width=&quot;1&quot; 
        marker-start=&quot;url(#trianglestart)&quot; 
        marker-end=&quot;url(#triangleend)&quot; /&gt;
&lt;/g&gt;</pre>
<p>These tags reference definitions in the <code>defs</code> section:</p>
<pre>&lt;marker id=&quot;trianglestart&quot; viewBox=&quot;0 0 10 10&quot; refX=&quot;0&quot; refY=&quot;5&quot; markerWidth=&quot;8&quot; markerHeight=&quot;8&quot; orient=&quot;auto&quot;&gt;
  &lt;!-- path looks like &lt; but closed --&gt;
  &lt;path d=&quot;M 10 0 L 0 5 L 10 10 z&quot; /&gt;
&lt;/marker&gt;
&lt;marker id=&quot;triangleend&quot; viewBox=&quot;0 0 10 10&quot; refX=&quot;10&quot; refY=&quot;5&quot; markerWidth=&quot;8&quot; markerHeight=&quot;8&quot; orient=&quot;auto&quot;&gt;
  &lt;!-- path looks like &gt; but closed --&gt;
  &lt;path d=&quot;M 0 0 L 10 5 L 0 10 z&quot; /&gt;
&lt;/marker&gt;</pre>
<p>The &quot;trick&quot; here is to place set the <code>refX</code> and <code>refY</code> coordinates such that the 
arrow tip is at the endpoint of the line.&nbsp; For example, we can disconnect 
the arrow from the line like this:</p>
<pre>refX=&quot;30&quot; refY=&quot;5&quot; </pre>
<p>Resulting in:</p>
<p><img border="0" src="linearrows2.png" width="178" height="106"></p>
<p>The <code>markerWidth</code> and </code>markerHeight</code> control the size 
of the arrow.&nbsp; For example:</p>
<pre>&lt;marker id=&quot;trianglestart&quot; viewBox=&quot;0 0 10 10&quot; refX=&quot;0&quot; refY=&quot;5&quot; markerWidth=&quot;22&quot; markerHeight=&quot;22&quot; orient=&quot;auto&quot;&gt;
  &lt;path d=&quot;M 10 0 L 0 5 L 10 10 z&quot; /&gt;
&lt;/marker&gt;</pre>
<p>Yields:</p>
<p><img border="0" src="linearrows3.png" width="158" height="155"></p>
<p>Because the orientation is &quot;auto&quot;, the arrowhead will rotate based on the 
orientation of the line -- very cool, as you don't have to do anything to make 
that work.</p>
<p>The <code>viewBox</code> attribute changes the coordinate system so that it coordinates 
specified in the path are relative to the <code>viewBox</code>.</p>
<h2><a name="Updates">Updates</a></h2>
5/4/2018 - Added Line Arrows</p>
<h2><a name="Conclusion68">Conclusion</a></h2>
<p>There's so much more to do!&nbsp; Undo/redo, zooming, rotations, a &quot;properties&quot; window 
for setting colors and stroke widths, font and font sizes, arrow endpoints, 
smart line connectors, grouping, moving shapes up/down the hierarchy, shape 
templates, and so 
forth.&nbsp; To a large degree, these are all bells and whistles (with some 
complexity, particularly with regards to rotations and connection points) which 
I'll continue to add.&nbsp; What this article has presented is a good baseline 
for the core functionality of a web-based diagramming tool.&nbsp; Stay tuned for 
Part II!</p>
<p>One of the most annoying issues was dealing with mouse events not being 
received by the intended shape.&nbsp; For example, rapid mouse movement by the 
user causes the shape being moved to lag and the underlying SVG element to start 
receiving mouse movement events.&nbsp; Mouse up events exactly on the connection 
point results in the connection point receiving the event, which is why I moved 
connection points to be below anchors.</p>

<p>One thing I noticed was that once I implemented a true MVC pattern, a lot of 
the complexity of managing the mouse state went away.&nbsp; In fact, with the 
MVC pattern in place, adding the line connections and updating the persistence 
to include connections was a breeze.</p>

<p>Lastly, this has been an incredibly useful exercise to learn about 
programmatically controlling SVG as well as learning some new things about 
Javascript.&nbsp; And while there's a lot more to do, I think I've laid an 
excellent foundation for continuing to enhance this application.</p>

</body>

</html>
